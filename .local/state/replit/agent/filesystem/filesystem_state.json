{"file_contents":{"app/src/main/java/com/tvplayer/app/skipdetection/MediaIdentifier.java":{"content":"package com.tvplayer.app.skipdetection;\n\npublic class MediaIdentifier {\n    private final String title;\n    private final String showName;\n    private final Integer seasonNumber;\n    private final Integer episodeNumber;\n    private final long runtimeSeconds;\n    private final String imdbId;\n    private final String tmdbId;\n    private final String traktId;\n    private final String tvdbId;\n\n    private MediaIdentifier(Builder builder) {\n        this.title = builder.title;\n        this.showName = builder.showName;\n        this.seasonNumber = builder.seasonNumber;\n        this.episodeNumber = builder.episodeNumber;\n        this.runtimeSeconds = builder.runtimeSeconds;\n        this.imdbId = builder.imdbId;\n        this.tmdbId = builder.tmdbId;\n        this.traktId = builder.traktId;\n        this.tvdbId = builder.tvdbId;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public String getShowName() {\n        return showName;\n    }\n\n    public Integer getSeasonNumber() {\n        return seasonNumber;\n    }\n\n    public Integer getEpisodeNumber() {\n        return episodeNumber;\n    }\n\n    public long getRuntimeSeconds() {\n        return runtimeSeconds;\n    }\n\n    public String getImdbId() {\n        return imdbId;\n    }\n\n    public String getTmdbId() {\n        return tmdbId;\n    }\n\n    public String getTraktId() {\n        return traktId;\n    }\n\n    public String getTvdbId() {\n        return tvdbId;\n    }\n\n    public boolean isTvShow() {\n        return seasonNumber != null && episodeNumber != null;\n    }\n\n    public String getCacheKey() {\n        if (isTvShow() && showName != null) {\n            return showName + \"_S\" + seasonNumber + \"E\" + episodeNumber;\n        }\n        return title != null ? title : \"unknown\";\n    }\n\n    public static class Builder {\n        private String title;\n        private String showName;\n        private Integer seasonNumber;\n        private Integer episodeNumber;\n        private long runtimeSeconds;\n        private String imdbId;\n        private String tmdbId;\n        private String traktId;\n        private String tvdbId;\n\n        public Builder setTitle(String title) {\n            this.title = title;\n            return this;\n        }\n\n        public Builder setShowName(String showName) {\n            this.showName = showName;\n            return this;\n        }\n\n        public Builder setSeasonNumber(Integer seasonNumber) {\n            this.seasonNumber = seasonNumber;\n            return this;\n        }\n\n        public Builder setEpisodeNumber(Integer episodeNumber) {\n            this.episodeNumber = episodeNumber;\n            return this;\n        }\n\n        public Builder setRuntimeSeconds(long runtimeSeconds) {\n            this.runtimeSeconds = runtimeSeconds;\n            return this;\n        }\n\n        public Builder setImdbId(String imdbId) {\n            this.imdbId = imdbId;\n            return this;\n        }\n\n        public Builder setTmdbId(String tmdbId) {\n            this.tmdbId = tmdbId;\n            return this;\n        }\n\n        public Builder setTraktId(String traktId) {\n            this.traktId = traktId;\n            return this;\n        }\n\n        public Builder setTvdbId(String tvdbId) {\n            this.tvdbId = tvdbId;\n            return this;\n        }\n\n        public MediaIdentifier build() {\n            return new MediaIdentifier(this);\n        }\n    }\n}","size_bytes":3373},"README.md":{"content":"Android TV application with ExoPlayer for Amazon Firestick and Android TV devices. Features custom player controls, configurable skip functionality (intro, recap, credits), audio/subtitle delay controls, and API key management.\n\n## Features\n\n### Custom Player Controls\n- **Comprehensive Time Display**:\n  - Current time of day (CTOD)\n  - Elapsed playtime\n  - Total runtime\n  - Remaining runtime\n  - Projected finish time\n- **Media Controls**: Play/Pause, Rewind 10s, Fast Forward 30s, Previous, Next\n- **Auto-hide controls** after 5 seconds of inactivity\n- **D-pad navigation** optimized for TV remote control\n\n### Skip Functionality\n- **Skip Intro**: Automatically skip show intros\n- **Skip Recap**: Skip \"previously on\" recaps\n- **Skip Credits**: Skip end credits\n- **Next Episode**: Prompt to play next episode\n- **Manual timing configuration** - set start/end seconds for each skip type\n- **Auto-skip toggles** - enable automatic skipping\n- **Skip buttons appear** during configured time ranges\n\n### Audio/Subtitle Sync\n- **Audio delay adjustment**: -500ms to +500ms (UI and storage complete)\n- **Subtitle delay adjustment**: -500ms to +500ms (UI and storage complete)\n- Quick adjustment dialogs with preset values\n- Values persist across restarts\n- **Note**: Delays are stored but **cannot be applied to playback** due to Media3 limitations (TextRenderer is final)\n- **Recommended**: Use external players like VLC or MX Player for delay functionality\n\n### Settings & Configuration\n- **API Keys Management**:\n  - Trakt API Key\n  - TMDB API Key\n  - TVDB API Key\n- **Debrid Servers**:\n  - Real-Debrid API Key\n  - TorBox API Key\n  - AllDebrid API Key\n- **Skip Timings**: Manual entry for intro, recap, credits, next episode (in seconds)\n- **All settings persist** across app restarts via SharedPreferences\n- **No rebuild required** to change any configuration\n\n### External Player Support\n- Compatible with **Stremio** and **Syncler+** integration\n- Handles VIEW intents with video URLs\n- Supports http:// and https:// video streams\n- Seamless external player handoff\n\n## Build Requirements\n\n### Prerequisites\n1. **Android SDK** (API Level 35)\n2. **Java JDK 11** or higher\n3. **Gradle 8.10.2** (included via wrapper)\n\n### Android SDK Setup (if not installed)\n\n#### On Linux/Replit:Download Android command line toolswget https://dl.google.com/android/repository/commandlinetools-linux-9477386_latest.zipSetup SDK directorymkdir -p ~/android-sdk/cmdline-tools\nunzip commandlinetools-linux-9477386_latest.zip -d ~/android-sdk/cmdline-tools\ncd ~/android-sdk/cmdline-tools\nmkdir latest\nmv cmdline-tools/* latest/ 2>/dev/null || mv bin lib NOTICE.txt source.properties latest/Set environment variables (add to ~/.bashrc for persistence)export ANDROID_HOME=~/android-sdk\nexport PATH=$ANDROID_HOME/cmdline-tools/latest/bin:$PATH\nexport PATH=$ANDROID_HOME/platform-tools:$PATHAccept licensesyes | sdkmanager --licensesInstall required SDK componentssdkmanager \"platform-tools\" \"platforms;android-35\" \"build-tools;35.0.0\"\n#### On macOS:brew install android-sdk\nexport ANDROID_HOME=/usr/local/share/android-sdk\nsdkmanager \"platform-tools\" \"platforms;android-35\" \"build-tools;35.0.0\"\n#### On Windows:\nDownload Android Studio or Android SDK command line tools from:\nhttps://developer.android.com/studio\n\n## Building the APK\n\n### Quick Build (using build script):chmod +x build.sh\n./build.sh\n### Manual Build:chmod +x gradlew\n./gradlew assembleDebug\n### Build Output\nAPK location: `app/build/outputs/apk/debug/app-debug.apk`\n\n## Installation\n\n### Install on Firestick/Android TV:\n\n#### Method 1: ADB (Android Debug Bridge)Enable ADB on Firestick: Settings > My Fire TV > Developer Options > ADB DebuggingConnect via IP addressadb connect :5555Install APKadb install app/build/outputs/apk/debug/app-debug.apk\n#### Method 2: USB Install\n1. Copy APK to USB drive\n2. Install a file manager on Firestick (e.g., \"X-plore File Manager\")\n3. Enable \"Install from Unknown Sources\"\n4. Navigate to APK and install\n\n#### Method 3: Downloader App\n1. Install \"Downloader\" app on Firestick\n2. Upload APK to web server or cloud storage\n3. Enter URL in Downloader and install\n\n## Configuration\n\n### Setting Up Skip Timings\n1. Open the app on your TV\n2. Press the **Settings** button (gear icon) in the player controls\n3. Navigate to \"Skip Timings\" section\n4. Enter start and end times (in seconds) for:\n   - Intro Start/End\n   - Recap Start/End\n   - Credits Start/End\n   - Next Episode Start\n5. Enable auto-skip toggles if desired\n\n### Adding API Keys\n1. Open Settings\n2. Navigate to \"API Keys\" section\n3. Enter your API keys for:\n   - Trakt (https://trakt.tv/oauth/applications)\n   - TMDB (https://www.themoviedb.org/settings/api)\n   - TVDB (https://thetvdb.com/api-information)\n4. Add debrid server keys as needed\n\n### Adjusting Audio/Subtitle Delay\nDuring playback:\n1. Show controls (tap screen or press OK/Select on remote)\n2. Press the **Audio Delay** or **Subtitle Delay** button\n3. Select preset delay value (-500ms to +500ms)\n\n## Usage\n\n### Standalone Mode\nLaunch from Android TV home screen (Leanback launcher)\n\n### External Player Mode (Stremio/Syncler)\n1. Install app on Firestick/Android TV\n2. In Stremio or Syncler, select a video\n3. Choose \"Play with\" or \"External Player\"\n4. Select \"TV Player\" from the list\n5. Video plays with skip functionality\n\n### Player Controls\n- **Click/Select**: Show/hide controls\n- **Play/Pause**: Toggle playback\n- **Rewind**: Seek backward 10 seconds\n- **Fast Forward**: Seek forward 30 seconds\n- **Previous**: Restart video\n- **Next**: Close player\n- **Skip Buttons**: Appear automatically during configured time ranges\n\n## Project Structure\n/\n├─ .github/\n│  └─ workflows/\n│     ├─ build.yml\n│     └─ unzip.yml\n├─ app/\n│  ├─ build.gradle                 # App-level Gradle config\n│  ├─ proguard-rules.pro\n│  └─ src/\n│     └─ main/\n│         ├─ AndroidManifest.xml   # App manifest with permissions\n│         ├─ java/\n│         │  └─ com/\n│         │     └─ tvplayer/\n│         │        └─ app/\n│         │           ├─ MainActivity.java\n│         │           ├─ PreferencesHelper.java\n│         │           ├─ SettingsActivity.java\n│         │           ├─ SkipMarkers.java\n│         │           └─ skipdetection/\n│         │              ├─ MediaIdentifier.java\n│         │              ├─ SkipDetectionCallback.java\n│         │              ├─ SkipDetectionResult.java\n│         │              ├─ SkipDetectionStrategy.java\n│         │              ├─ SmartSkipManager.java\n│         │              └─ strategies/\n│         │                 ├─ CacheStrategy.java\n│         │                 ├─ ChapterStrategy.java\n│         │                 ├─ IntroHaterStrategy.java\n│         │                 ├─ IntroSkipperStrategy.java\n│         │                 ├─ ManualPreferenceStrategy.java\n│         │                 └─ MetadataHeuristicStrategy.java\n│         └─ res/\n│            ├─ drawable/\n│            │  ├─ control_button_background.xml\n│            │  ├─ ic_launcher_foreground.xml\n│            │  └─ skip_button_background.xml\n│            ├─ layout/\n│            │  ├─ activity_main.xml\n│            │  └─ activity_settings.xml\n│            ├─ mipmap-anydpi-v26/\n│            │  └─ ic_launcher.xml\n│            ├─ values/\n│            │  ├─ colors.xml\n│            │  ├─ strings.xml\n│            │  └─ styles.xml\n│            └─ xml/\n│               └─ preferences.xml\n├─ gradle/\n│  └─ wrapper/\n│     ├─ gradle-wrapper.jar\n│     └─ gradle-wrapper.properties\n├─ .gitignore\n├─ build.gradle                   # Project-level Gradle config\n├─ build.sh                       # Build script\n├─ gradle.properties\n├─ gradlew                        # Gradle wrapper exec (Linux/macOS)\n├─ gradlew.bat                   # Gradle wrapper exec (Windows)\n├─ README.md                     # Project documentation\n└─ settings.gradle               # Defines project modules\n## Technical Details\n\n### Specifications\n- **Target SDK**: API 35 (Android 15)\n- **Minimum SDK**: API 22 (Android 5.1 - Firestick compatible)\n- **Build System**: Gradle 8.10.2\n- **Language**: Java 11\n- **Media Framework**: AndroidX Media3 (ExoPlayer) 1.7.1\n\n### Dependencies\n- AndroidX Media3 components (ExoPlayer) 1.7.1 - Video playback\n- AndroidX AppCompat 1.6.1 - Backward compatibility\n- Google Material Design Components 1.9.0 - UI elements\n- AndroidX Leanback 1.1.0-rc02 - TV optimization\n- AndroidX Preference 1.2.1 - Settings UI\n- OkHttp 4.11.0 - Network requests\n- Gson 2.10.1 - JSON parsing\n- AndroidX Multidex 2.0.1 - Multidex support for minSdk 22+\n\n### Permissions\n- `INTERNET` - Stream video content\n- `ACCESS_NETWORK_STATE` - Check connectivity\n\n## Troubleshooting\n\n### Build fails with \"SDK not found\"\nSet ANDROID_HOME environment variable:export ANDROID_HOME=~/android-sdk\n### APK won't install on Firestick\nEnable \"Install from Unknown Sources\" in Firestick settings:\nSettings > My Fire TV > Developer Options > Apps from Unknown Sources\n\n### Controls don't appear\n- Click/tap the screen or press OK/Select on your remote\n- Controls auto-hide after 5 seconds\n\n### Skip buttons don't show\n- Verify skip timings are configured in Settings\n- Ensure current playback position is within configured time range\n- Skip timings are in seconds, not minutes\n\n### External player not recognized\nEnsure the app is installed and appears in the system's list of video players\n\n## Development\n\n### Modifying the App\n1. Edit source files in `app/src/main/java/com/tvplayer/app/`\n2. Modify layouts in `app/src/main/res/layout/`\n3. Update strings in `app/src/main/res/values/strings.xml`\n4. Rebuild: `./build.sh`\n\n### Adding Features\n- Skip timings are loaded from SharedPreferences in `PreferencesHelper`\n- Add new preferences in `app/src/main/res/xml/preferences.xml`\n- Player logic is in `MainActivity.java`\n\n## License\n\nThis project is provided as-is for personal use.\n\n## Support\n\nFor issues or questions:\n1. Verify skip timing configuration in Settings\n2. Ensure API keys are correct\n3. Confirm video URL is valid (http/https)\n4. Check Firestick internet connectivity\n\n## Credits\n\nBuilt with:\n- ExoPlayer (Google)\n- AndroidX Libraries (Google)\n- Material Design Components (Google)","size_bytes":10561},"app/src/main/java/com/tvplayer/app/skipdetection/strategies/CacheStrategy.java":{"content":"package com.tvplayer.app.skipdetection.strategies;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\n\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\nimport com.tvplayer.app.skipdetection.MediaIdentifier;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegment;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.DetectionSource;\nimport com.tvplayer.app.skipdetection.SkipDetectionStrategy;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CacheStrategy implements SkipDetectionStrategy {\n\n    private static final String PREFS_NAME = \"SkipDetectionCache\";\n    private static final long CACHE_EXPIRY_MS = 30L * 24 * 60 * 60 * 1000;\n\n    private final SharedPreferences prefs;\n    private final Gson gson;\n\n    public CacheStrategy(Context context) {\n        this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);\n        this.gson = new Gson();\n    }\n\n    @Override\n    public SkipDetectionResult detect(MediaIdentifier mediaIdentifier) {\n        String cacheKey = mediaIdentifier.getCacheKey();\n        String cachedJson = prefs.getString(cacheKey, null);\n\n        if (cachedJson == null) {\n            return SkipDetectionResult.failed(DetectionSource.CACHE, \"No cached data\");\n        }\n\n        try {\n            CachedSkipData cachedData = gson.fromJson(cachedJson, CachedSkipData.class);\n\n            if (System.currentTimeMillis() - cachedData.timestamp > CACHE_EXPIRY_MS) {\n                prefs.edit().remove(cacheKey).apply();\n                return SkipDetectionResult.failed(DetectionSource.CACHE, \"Cache expired\");\n            }\n\n            return SkipDetectionResult.success(\n                DetectionSource.CACHE,\n                0.95f,\n                cachedData.segments.toArray(new SkipSegment[0])\n            );\n\n        } catch (Exception e) {\n            return SkipDetectionResult.failed(DetectionSource.CACHE, \"Cache read error: \" + e.getMessage());\n        }\n    }\n\n    public void cacheResult(MediaIdentifier mediaIdentifier, SkipDetectionResult result) {\n        if (result == null || !result.isSuccess() || result.getSource() == DetectionSource.CACHE) {\n            return;\n        }\n\n        String cacheKey = mediaIdentifier.getCacheKey();\n        List<SkipSegment> segmentsList = new ArrayList<>();\n        for (SkipSegment segment : result.getSegments()) {\n            segmentsList.add(segment);\n        }\n\n        CachedSkipData cachedData = new CachedSkipData();\n        cachedData.segments = segmentsList;\n        cachedData.timestamp = System.currentTimeMillis();\n        cachedData.source = result.getSource().name();\n        cachedData.confidence = result.getConfidence();\n\n        String json = gson.toJson(cachedData);\n        prefs.edit().putString(cacheKey, json).apply();\n    }\n\n    public void clearCache() {\n        prefs.edit().clear().apply();\n    }\n\n    public void invalidateCache(MediaIdentifier mediaIdentifier) {\n        String cacheKey = mediaIdentifier.getCacheKey();\n        prefs.edit().remove(cacheKey).apply();\n    }\n\n    @Override\n    public String getStrategyName() {\n        return \"Local Cache\";\n    }\n\n    @Override\n    public boolean isAvailable() {\n        return true;\n    }\n\n    @Override\n    public int getPriority() {\n        return 100;\n    }\n\n    private static class CachedSkipData {\n        List<SkipSegment> segments;\n        long timestamp;\n        String source;\n        float confidence;\n    }\n}","size_bytes":3570},"app/src/main/java/com/tvplayer/app/SkipMarkers.java":{"content":"package com.tvplayer.app;\n\n/**\n * SkipMarkers\n * FUNCTION: A data class that holds the active, in-use skip segments\n * (Intro, Recap, Credits) and the Next Episode marker.\n * INTERACTS WITH: MainActivity.java (which sets/gets data from this class).\n * PERSONALIZATION: The 'WINDOW_SECONDS' for the Next Episode button can be\n * changed to show the button earlier or later.\n */\npublic class SkipMarkers {\n\n    /**\n     * TimeRange: An inner class to hold the start and end of a segment\n     * (Intro, Recap, Credits). All times are stored in seconds (int).\n     */\n    public static class TimeRange {\n        // # The start of the segment in seconds\n        public final int start; \n        // # The end of the segment in seconds\n        public final int end; \n\n        public TimeRange(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        /**\n         * Checks if the current video position is within the segment's range.\n         * @param positionSeconds The current video time in seconds.\n         * @return True if the position is between start (inclusive) and end (exclusive).\n         */\n        public boolean contains(long positionSeconds) {\n            // # Check if time is within the valid range\n            return positionSeconds >= start && positionSeconds < end;\n        }\n\n        /**\n         * Checks if the time range is valid (start is non-negative and before end).\n         * @return True if the marker is set correctly.\n         */\n        public boolean isValid() {\n            return start >= 0 && end > start;\n        }\n    }\n\n    // --- Skip Segment Data Fields ---\n    private TimeRange intro;\n    private TimeRange recap;\n    private TimeRange credits;\n    private int nextEpisodeStart;\n\n    /**\n     * Constructor: Initializes all markers to an invalid (cleared) state.\n     */\n    public SkipMarkers() {\n        clearAll();\n    }\n\n    /**\n     * Clears all segment markers. Called when new media is loaded.\n     */\n    public void clearAll() {\n        this.intro = new TimeRange(-1, -1);\n        this.recap = new TimeRange(-1, -1);\n        this.credits = new TimeRange(-1, -1);\n        this.nextEpisodeStart = -1;\n    }\n\n    // --- Setter Methods (Called by MainActivity) ---\n\n    public void setIntro(int start, int end) {\n        this.intro = new TimeRange(start, end);\n    }\n\n    public void setRecap(int start, int end) {\n        this.recap = new TimeRange(start, end);\n    }\n\n    public void setCredits(int start, int end) {\n        this.credits = new TimeRange(start, end);\n    }\n\n    public void setNextEpisodeStart(int start) {\n        this.nextEpisodeStart = start;\n    }\n\n    // --- Getter Methods (For performing the seek in MainActivity) ---\n\n    // # FIX: Added getIntro() to return the TimeRange object, fixing build error\n    public TimeRange getIntro() { return intro; }\n\n    // # FIX: Added getRecap() to return the TimeRange object, fixing build error\n    public TimeRange getRecap() { return recap; }\n\n    public TimeRange getCredits() { return credits; }\n\n    public int getNextEpisodeStart() { return nextEpisodeStart; }\n\n    // --- Logic Methods (For controlling button visibility in MainActivity) ---\n\n    /**\n     * Determines if the player is currently inside the Intro segment.\n     * @param positionSeconds The current video time in seconds.\n     * @return true if the button should be shown.\n     */\n    public boolean isInIntro(long positionSeconds) {\n        return intro.isValid() && intro.contains(positionSeconds);\n    }\n\n    public boolean isInRecap(long positionSeconds) {\n        return recap.isValid() && recap.contains(positionSeconds);\n    }\n\n    public boolean isInCredits(long positionSeconds) {\n        return credits.isValid() && credits.contains(positionSeconds);\n    }\n\n    /**\n     * Determines if the Next Episode button should be displayed.\n     * @param positionSeconds The current video time in seconds.\n     * @return true if the button should be shown.\n     */\n    public boolean isAtNextEpisode(long positionSeconds) {\n        // # Defines a 15-second window before the marker time to display the button.\n        final int WINDOW_SECONDS = 15; \n\n        // # Show the button if the marker is set and we are within the display window\n        return nextEpisodeStart > 0 && \n               positionSeconds >= (nextEpisodeStart - WINDOW_SECONDS) &&\n               positionSeconds < (nextEpisodeStart + WINDOW_SECONDS); // # Show for a bit after too\n    }\n}","size_bytes":4482},"app/src/main/java/com/tvplayer/app/skipdetection/SkipDetectionResult.java":{"content":"package com.tvplayer.app.skipdetection;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * SkipDetectionResult\n * FUNCTION: A data class that holds the results of a skip detection operation.\n * It contains the source, success status, and a list of found segments.\n * INTERACTS WITH: All *Strategy.java files (which create this) and MainActivity.java (which consumes this).\n * PERSONALIZATION: You can add more metadata to this class if strategies need to pass more info (e.g., confidence score).\n */\npublic class SkipDetectionResult {\n\n    // --- Enums ---\n\n    /**\n     * SkipSegmentType: Defines the type of segment found.\n     * FIX: Added NEXT_EPISODE to support the \"Next Episode\" button logic.\n     */\n    public enum SkipSegmentType {\n        INTRO,\n        RECAP,\n        CREDITS,\n        NEXT_EPISODE, // Added to fix compile error\n        UNKNOWN\n    }\n\n    /**\n     * DetectionSource: Identifies which strategy found the result.\n     * FIX: Added getDisplayName() to provide a user-friendly name for Toasts.\n     */\n    public enum DetectionSource {\n        MANUAL_PREFERENCE(\"Manual Settings\"),\n        CACHE(\"Cache\"),\n        CHAPTER_MARKERS(\"Chapter Markers\"),\n        METADATA_HEURISTIC(\"Metadata Heuristics\"),\n        INTROHATER_API(\"IntroHater API\"),\n        INTRO_SKIPPER_API(\"Intro-Skipper API\"),\n        AUDIO_FINGERPRINT(\"Audio Scan\"),\n        NONE(\"None\");\n\n        private final String displayName;\n\n        DetectionSource(String displayName) {\n            this.displayName = displayName;\n        }\n\n        // # FIX: Added this helper method to fix compile error in MainActivity\n        public String getDisplayName() {\n            return displayName;\n        }\n    }\n\n    // --- Inner Class: SkipSegment ---\n\n    /**\n     * SkipSegment: Holds the start and end time for a single skip-able segment.\n     */\n    public static class SkipSegment {\n        public final SkipSegmentType type;\n        public final int startSeconds;\n        public final int endSeconds;\n\n        public SkipSegment(SkipSegmentType type, int startSeconds, int endSeconds) {\n            this.type = type;\n            this.startSeconds = startSeconds;\n            this.endSeconds = endSeconds;\n        }\n\n        public boolean isValid() {\n            return endSeconds > startSeconds && startSeconds >= 0;\n        }\n    }\n\n    // --- Main Class Fields ---\n\n    private final boolean success;\n    private final DetectionSource source;\n    private final String errorMessage;\n    private final List<SkipSegment> segments;\n    private final float confidence; // Confidence score (0.0 to 1.0)\n\n    // --- Constructors ---\n\n    // # Private constructor, use static factory methods\n    private SkipDetectionResult(boolean success, DetectionSource source, float confidence, List<SkipSegment> segments, String errorMessage) {\n        this.success = success;\n        this.source = source;\n        this.confidence = confidence;\n        this.segments = segments != null ? Collections.unmodifiableList(segments) : Collections.emptyList();\n        this.errorMessage = errorMessage;\n    }\n\n    // --- Static Factory Methods ---\n\n    /**\n     * Creates a successful result with one or more segments.\n     */\n    public static SkipDetectionResult success(DetectionSource source, float confidence, SkipSegment... segments) {\n        List<SkipSegment> segmentList = new ArrayList<>();\n        if (segments != null) {\n            for (SkipSegment segment : segments) {\n                if (segment != null && segment.isValid()) {\n                    segmentList.add(segment);\n                }\n            }\n        }\n        if (segmentList.isEmpty()) {\n            return failed(source, \"Success reported but no valid segments provided.\");\n        }\n        return new SkipDetectionResult(true, source, confidence, segmentList, null);\n    }\n\n    /**\n     * Creates a failed result.\n     */\n    public static SkipDetectionResult failed(DetectionSource source, String errorMessage) {\n        return new SkipDetectionResult(false, source, 0f, null, errorMessage);\n    }\n\n    // --- Public Getters ---\n\n    public boolean isSuccess() {\n        return success;\n    }\n\n    public DetectionSource getSource() {\n        return source;\n    }\n\n    public String getErrorMessage() {\n        return errorMessage;\n    }\n\n    public float getConfidence() {\n        return confidence;\n    }\n\n    public List<SkipSegment> getSegments() {\n        return segments;\n    }\n\n    /**\n     * Helper to get the first segment matching a specific type.\n     */\n    public SkipSegment getSegmentByType(SkipSegmentType type) {\n        for (SkipSegment segment : segments) {\n            if (segment.type == type) {\n                return segment;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Helper to check if a segment of a specific type exists.\n     */\n    public boolean hasSegmentType(SkipSegmentType type) {\n        for (SkipSegment segment : segments) {\n            if (segment.type == type) {\n                return true;\n            }\n        }\n        return false;\n    }\n}","size_bytes":5096},"app/src/main/java/com/tvplayer/app/ApiService.java":{"content":"package com.tvplayer.app;\n\nimport android.os.Handler;\nimport android.os.Looper;\n\nimport com.google.gson.Gson;\n\nimport java.io.IOException;\n\nimport okhttp3.Call;\nimport okhttp3.Callback;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\npublic class ApiService {\n    private final OkHttpClient client;\n    private final Gson gson;\n\n    public ApiService() {\n        this.client = new OkHttpClient();\n        this.gson = new Gson();\n    }\n\n    public interface SkipMarkersCallback {\n        void onSuccess(SkipMarkers markers);\n        void onError(Exception e);\n    }\n\n    public void fetchSkipMarkers(String url, SkipMarkersCallback callback) {\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        client.newCall(request).enqueue(new Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n                new Handler(Looper.getMainLooper()).post(() -> callback.onError(e));\n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                try {\n                    if (!response.isSuccessful()) {\n                        throw new IOException(\"Unexpected code \" + response);\n                    }\n\n                    String jsonData = response.body().string();\n                    SkipMarkers markers = gson.fromJson(jsonData, SkipMarkers.class);\n                    \n                    new Handler(Looper.getMainLooper()).post(() -> callback.onSuccess(markers));\n                } catch (Exception e) {\n                    new Handler(Looper.getMainLooper()).post(() -> callback.onError(e));\n                }\n            }\n        });\n    }\n}\n","size_bytes":1748},"app/src/main/java/com/tvplayer/app/skipdetection/strategies/IntroHaterStrategy.java":{"content":"package com.tvplayer.app.skipdetection.strategies;\n\nimport android.util.Log;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonObject;\nimport com.tvplayer.app.skipdetection.MediaIdentifier;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegment;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegmentType;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.DetectionSource;\nimport com.tvplayer.app.skipdetection.SkipDetectionStrategy;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\n/**\n * IntroHaterStrategy\n * FUNCTION: Detects skip segments by querying the IntroHater community API.\n * INTERACTS WITH: IntroHater public server (requires Internet), MediaIdentifier.java (for TMDB ID).\n * PERSONALIZATION: The API_BASE_URL can be changed if the service moves.\n */\npublic class IntroHaterStrategy implements SkipDetectionStrategy {\n\n    private static final String TAG = \"IntroHaterStrategy\";\n    // # The community API base URL.\n    private static final String API_BASE_URL = \"https://introhater.com/api\";\n    private static final int TIMEOUT_SECONDS = 8;\n\n    private final OkHttpClient httpClient;\n    private final Gson gson;\n\n    public IntroHaterStrategy() {\n        // # HTTP client setup with a reasonable timeout\n        this.httpClient = new OkHttpClient.Builder()\n            .connectTimeout(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n            .readTimeout(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n            .writeTimeout(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n            .build();\n        this.gson = new Gson();\n    }\n\n    // # Core detection logic: Constructs a URL and fetches skip segments from the API.\n    @Override\n    public SkipDetectionResult detect(MediaIdentifier mediaIdentifier) {\n        String tmdbId = mediaIdentifier.getTmdbId();\n        Integer season = mediaIdentifier.getSeasonNumber();\n        Integer episode = mediaIdentifier.getEpisodeNumber();\n\n        if (tmdbId == null || tmdbId.isEmpty() || season == null || episode == null) {\n            return SkipDetectionResult.failed(DetectionSource.INTROHATER_API, \"Missing TMDB ID or episode info.\");\n        }\n\n        // # Constructs the API URL for a specific episode.\n        String url = String.format(\"%s/tmdb/%s/season/%d/episode/%d\", API_BASE_URL, tmdbId, season, episode);\n\n        Request request = new Request.Builder()\n            .url(url)\n            .build();\n\n        try (Response response = httpClient.newCall(request).execute()) {\n            if (response.isSuccessful() && response.body() != null) {\n                String json = response.body().string();\n                List<SkipSegment> segments = parseResponse(json);\n\n                if (!segments.isEmpty()) {\n                    Log.d(TAG, \"IntroHater detection successful with \" + segments.size() + \" segments\");\n                    // # Returns a high-confidence result\n                    return SkipDetectionResult.success(\n                        DetectionSource.INTROHATER_API,\n                        0.80f,\n                        segments.toArray(new SkipSegment[0])\n                    );\n                } else {\n                    return SkipDetectionResult.failed(DetectionSource.INTROHATER_API, \"API returned no skip data.\");\n                }\n            } else {\n                return SkipDetectionResult.failed(DetectionSource.INTROHATER_API, \n                    \"API call failed: \" + response.code());\n            }\n        } catch (Exception e) {\n            Log.e(TAG, \"Network error during IntroHater lookup\", e);\n            return SkipDetectionResult.failed(DetectionSource.INTROHATER_API, \"Network error: \" + e.getMessage());\n        }\n    }\n\n    // # Helper method to parse the JSON response from the API.\n    private List<SkipSegment> parseResponse(String json) {\n        List<SkipSegment> segments = new ArrayList<>();\n        try {\n            JsonObject root = gson.fromJson(json, JsonObject.class);\n            if (root.has(\"segments\") && root.get(\"segments\").isJsonArray()) {\n                JsonArray segmentsArray = root.get(\"segments\").getAsJsonArray();\n                for (int i = 0; i < segmentsArray.size(); i++) {\n                    JsonObject segment = segmentsArray.get(i).getAsJsonObject();\n                    String type = segment.has(\"type\") ? segment.get(\"type\").getAsString().toLowerCase() : \"\";\n                    int start = segment.has(\"start\") ? segment.get(\"start\").getAsInt() : 0;\n                    int end = segment.has(\"end\") ? segment.get(\"end\").getAsInt() : 0;\n\n                    if (start >= 0 && end > start) {\n                        if (type.contains(\"intro\") || type.contains(\"opening\")) {\n                            segments.add(new SkipSegment(SkipSegmentType.INTRO, start, end));\n                        } else if (type.contains(\"recap\")) {\n                            segments.add(new SkipSegment(SkipSegmentType.RECAP, start, end));\n                        } else if (type.contains(\"credits\") || type.contains(\"outro\")) {\n                            segments.add(new SkipSegment(SkipSegmentType.CREDITS, start, end));\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            Log.e(TAG, \"Error parsing IntroHater response\", e);\n        }\n        return segments;\n    }\n\n    @Override\n    public String getStrategyName() {\n        return \"IntroHater Community API\";\n    }\n\n    @Override\n    public boolean isAvailable() {\n        return true; // # The API is generally always available to try.\n    }\n\n    @Override\n    public int getPriority() {\n        // # FIX: Set to 400 for P1 Priority (Category 3: Community Servers).\n        return 400;\n    }\n}","size_bytes":5901},"app/src/main/java/com/tvplayer/app/skipdetection/strategies/ChapterStrategy.java":{"content":"package com.tvplayer.app.skipdetection.strategies;\n\nimport android.util.Log;\n\nimport androidx.media3.common.Metadata;\nimport androidx.media3.common.Player;\nimport androidx.media3.extractor.metadata.id3.ChapterFrame;\nimport androidx.media3.extractor.metadata.id3.TextInformationFrame;\n\nimport com.tvplayer.app.skipdetection.MediaIdentifier;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegment;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegmentType;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.DetectionSource;\nimport com.tvplayer.app.skipdetection.SkipDetectionStrategy;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * ChapterStrategy\n * FUNCTION: Detects skip segments by listening for embedded Chapter markers (e.g., ID3 tags)\n * in the media stream. This is a very reliable, high-priority source.\n * INTERACTS WITH: SmartSkipManager.java (which calls it), Player (Media3) (which it listens to).\n * PERSONALIZATION: The 'title.toLowerCase().contains(...)' logic can be expanded\n * to support more chapter names (e.g., \"opening\", \"ending\", \"previously on\").\n */\npublic class ChapterStrategy implements SkipDetectionStrategy {\n\n    private static final String TAG = \"ChapterStrategy\";\n    private Player player;\n    private final List<ChapterData> capturedChapters = new CopyOnWriteArrayList<>();\n    private Player.Listener metadataListener;\n\n    /**\n     * FIX: Constructor is now empty. The player is provided later via rebindToPlayer\n     * to avoid the circular dependency / startup order bug.\n     */\n    public ChapterStrategy() {\n        // # Player is not available at construction time\n    }\n\n    /**\n     * FIX: This method is called by SmartSkipManager once the player is ready.\n     * It binds this strategy to the active player instance.\n     * @param player The ExoPlayer/Media3 instance.\n     */\n    public void rebindToPlayer(Player player) {\n        // # If we're binding to a new player, remove the listener from the old one\n        if (this.player != null && this.metadataListener != null) {\n            try {\n                this.player.removeListener(this.metadataListener);\n            } catch (Exception e) {\n                Log.w(TAG, \"Failed to remove old listener, player may be released.\");\n            }\n        }\n\n        this.player = player;\n        this.capturedChapters.clear();\n\n        if (player != null) {\n            setupMetadataListener();\n        }\n    }\n\n    /**\n     * Sets up the Media3 player listener to capture metadata events.\n     */\n    private void setupMetadataListener() {\n        // # Create the listener\n        this.metadataListener = new Player.Listener() {\n            @Override\n            public void onMetadata(Metadata metadata) {\n                // # This callback fires when new metadata (like chapters) is found in the stream\n                for (int i = 0; i < metadata.length(); i++) {\n                    Metadata.Entry entry = metadata.get(i);\n                    // # Check if the metadata entry is a ChapterFrame\n                    if (entry instanceof ChapterFrame) {\n                        ChapterFrame chapter = (ChapterFrame) entry;\n                        // # The 'id' field often contains the chapter title\n                        String title = chapter.id; \n\n                        // # Times are in milliseconds, convert to seconds\n                        int startSec = (int) (chapter.startTimeMs / 1000);\n                        int endSec = (int) (chapter.endTimeMs / 1000);\n\n                        // # Heuristic to determine segment type from the title (e.g., 'Intro', 'Opening')\n                        if (title.toLowerCase().contains(\"intro\") || title.toLowerCase().contains(\"opening\")) {\n                            capturedChapters.add(new ChapterData(SkipSegmentType.INTRO.name(), startSec, endSec));\n                        } else if (title.toLowerCase().contains(\"recap\")) {\n                            capturedChapters.add(new ChapterData(SkipSegmentType.RECAP.name(), startSec, endSec));\n                        } else if (title.toLowerCase().contains(\"credits\") || title.toLowerCase().contains(\"outro\")) {\n                            capturedChapters.add(new ChapterData(SkipSegmentType.CREDITS.name(), startSec, endSec));\n                        }\n\n                        Log.d(TAG, \"Captured Chapter: \" + title + \" [\" + startSec + \"s to \" + endSec + \"s]\");\n                    }\n                    // # Also check for generic TextInformationFrame, sometimes used for chapter cues.\n                    else if (entry instanceof TextInformationFrame) {\n                        // This logic is complex and not fully implemented, but shows potential\n                        Log.d(TAG, \"Ignored TextInformationFrame: \" + ((TextInformationFrame) entry).id);\n                    }\n                }\n            }\n        };\n\n        // # Attach the listener to the player\n        this.player.addListener(this.metadataListener);\n    }\n\n    /**\n     * Core detection logic: Reads the chapters captured by the listener.\n     * This is called by SmartSkipManager on a background thread.\n     */\n    @Override\n    public SkipDetectionResult detect(MediaIdentifier mediaIdentifier) {\n        if (!isAvailable()) {\n            return SkipDetectionResult.failed(DetectionSource.CHAPTER_MARKERS, \"Player is not available or bound\");\n        }\n\n        try {\n            List<SkipSegment> segments = new ArrayList<>();\n\n            // # Loop through the stored chapter data\n            for (ChapterData chapter : capturedChapters) {\n                // # Convert the stored type string back to an enum\n                String typeUpper = chapter.type.toUpperCase();\n                SkipSegmentType type = SkipSegmentType.valueOf(typeUpper);\n\n                if (chapter.endSec > chapter.startSec) {\n                    segments.add(new SkipSegment(type, chapter.startSec, chapter.endSec));\n                }\n            }\n\n            if (segments.isEmpty()) {\n                return SkipDetectionResult.failed(DetectionSource.CHAPTER_MARKERS, \n                    \"No matching chapter segments found.\");\n            }\n\n            Log.d(TAG, \"Chapter detection successful with \" + segments.size() + \" segments\");\n            // # Returns a high-confidence result, as chapter markers are very accurate\n            return SkipDetectionResult.success(\n                DetectionSource.CHAPTER_MARKERS,\n                0.90f, // High confidence\n                segments.toArray(new SkipSegment[0])\n            );\n\n        } catch (Exception e) {\n            Log.e(TAG, \"Error detecting chapters\", e);\n            return SkipDetectionResult.failed(DetectionSource.CHAPTER_MARKERS, \"Error reading chapters: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Clears the list of captured chapters, usually called before loading a new media item.\n     */\n    public void clearCapturedChapters() {\n        capturedChapters.clear();\n    }\n\n    @Override\n    public String getStrategyName() {\n        return \"Chapter Markers (ID3/EMSG Metadata)\";\n    }\n\n    @Override\n    public boolean isAvailable() {\n        // # Strategy is available if a player is bound and the listener is set up.\n        return player != null && metadataListener != null;\n    }\n\n    @Override\n    public int getPriority() {\n        // # FIX: Set to 500 for P1 Priority (Category 1: Chapter/Metadata).\n        return 500;\n    }\n\n    // # Private class to hold parsed chapter data temporarily.\n    private static class ChapterData {\n        String type;\n        int startSec;\n        int endSec;\n\n        ChapterData(String type, int startSec, int endSec) {\n            this.type = type;\n            this.startSec = startSec;\n            this.endSec = endSec;\n        }\n    }\n}","size_bytes":7898},"app/src/main/java/com/tvplayer/app/skipdetection/SmartSkipManager.java":{"content":"package com.tvplayer.app.skipdetection;\n\nimport android.content.Context;\nimport android.os.Handler;\nimport android.os.Looper;\nimport android.util.Log;\n\nimport androidx.media3.common.Player;\n\nimport com.tvplayer.app.PreferencesHelper;\n// # Import the new audio strategy\nimport com.tvplayer.app.skipdetection.strategies.AudioFingerprintStrategy; \nimport com.tvplayer.app.skipdetection.strategies.CacheStrategy;\nimport com.tvplayer.app.skipdetection.strategies.ChapterStrategy;\nimport com.tvplayer.app.skipdetection.strategies.IntroHaterStrategy;\nimport com.tvplayer.app.skipdetection.strategies.IntroSkipperStrategy;\nimport com.tvplayer.app.skipdetection.strategies.ManualPreferenceStrategy;\nimport com.tvplayer.app.skipdetection.strategies.MetadataHeuristicStrategy;\n\n// # FIX: Added this import to resolve the 'cannot find symbol: variable DetectionSource' error\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.DetectionSource;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * SmartSkipManager\n * FUNCTION: Coordinates all skip detection strategies using a tiered priority system.\n *           Cache is checked first, then all strategies run concurrently, and the\n *           best result is selected based on TIER (priority) first, then confidence.\n * INTERACTS WITH: All *Strategy.java files, MainActivity.java, PreferencesHelper.java.\n * \n * PRIORITY TIERS (Reliability Levels):\n *   - Tier 600: Cache (checked synchronously before other strategies)\n *   - Tier 500: Chapter Markers & Metadata Heuristics (most reliable)\n *   - Tier 400: Community APIs (IntroSkipper, IntroHater) (moderately reliable)\n *   - Tier 300: Audio Fingerprinting (when implemented)\n *   - Tier 100: Manual User Preferences (final failsafe)\n * \n * SELECTION LOGIC:\n *   1. Higher tier (priority) always wins over lower tier, regardless of confidence\n *   2. Within same tier, highest confidence wins\n *   3. Manual preferences only surface when all higher tiers fail\n * \n * FIXED: Tiered priority system ensures reliable strategies are preferred over\n *        manual fallbacks, and metadata strategies have time to populate.\n * \n * PERSONALIZATION:\n * - DETECTION_TIMEOUT_MS: Max wait time for strategies (default 10 seconds).\n * - METADATA_WAIT_MS: Additional wait for chapter metadata to populate (default 2 seconds).\n * - EXECUTOR_THREADS: Number of concurrent strategy executions.\n */\npublic class SmartSkipManager {\n\n    private static final String TAG = \"SmartSkipManager\";\n    // # Max time (10 seconds) to wait for all strategies to finish.\n    private static final int DETECTION_TIMEOUT_MS = 10000;\n    // # Additional wait time for metadata-driven strategies (e.g., chapters) to populate\n    private static final int METADATA_WAIT_MS = 2000;\n    // # Number of strategies to run at the same time.\n    private static final int EXECUTOR_THREADS = 4;\n\n    private final PreferencesHelper prefsHelper;\n    private final ExecutorService executorService; \n    private final Handler mainHandler;\n    private final CacheStrategy cacheStrategy;\n    private final List<SkipDetectionStrategy> strategies;\n\n    // # Special reference to ChapterStrategy so we can rebind the player\n    private final ChapterStrategy chapterStrategy;\n\n    /**\n     * Constructor\n     * FUNCTION: Initializes all strategies and sorts them by priority.\n     * FIX: No longer takes a Player object to fix the startup build error.\n     */\n    public SmartSkipManager(Context context, PreferencesHelper prefsHelper) {\n        this.prefsHelper = prefsHelper;\n        this.executorService = Executors.newFixedThreadPool(EXECUTOR_THREADS);\n        this.mainHandler = new Handler(Looper.getMainLooper());\n\n        // # Initialize CacheStrategy (which is run separately)\n        this.cacheStrategy = new CacheStrategy(context);\n\n        // # Initialize all detection strategies\n        this.strategies = new ArrayList<>();\n\n        // # Create the ChapterStrategy instance (it's player-less for now)\n        this.chapterStrategy = new ChapterStrategy();\n\n        // # Add all strategies to the list\n        // # P1 Priority 5 (Lowest)\n        this.strategies.add(new ManualPreferenceStrategy(prefsHelper));\n        // # P1 Priority 4\n        this.strategies.add(new AudioFingerprintStrategy()); \n        // # P1 Priority 3\n        this.strategies.add(new IntroHaterStrategy());\n        this.strategies.add(new IntroSkipperStrategy());\n        // # P1 Priority 1 (Highest)\n        this.strategies.add(new MetadataHeuristicStrategy(prefsHelper));\n        this.strategies.add(this.chapterStrategy); // # Add the instance we saved\n\n        // # Sort the strategies based on their priority score (Highest number = Highest priority)\n        Collections.sort(this.strategies, Comparator.comparingInt(SkipDetectionStrategy::getPriority).reversed());\n\n        // # Log the final sorted order for debugging\n        Log.i(TAG, \"SmartSkipManager initialized. Strategy Priority Order:\");\n        for (int i = 0; i < this.strategies.size(); i++) {\n            SkipDetectionStrategy s = this.strategies.get(i);\n            Log.i(TAG, String.format(\"  #%d: %s (Priority=%d)\", i + 1, s.getStrategyName(), s.getPriority()));\n        }\n    }\n\n    /**\n     * rebindPlayer\n     * FUNCTION: Binds the player to strategies that need it (like ChapterStrategy).\n     * This is called from MainActivity once the player is in the STATE_READY.\n     * @param player The prepared Media3 Player instance.\n     */\n    public void rebindPlayer(Player player) {\n        // # Pass the player to the chapter strategy\n        if (chapterStrategy != null) {\n            chapterStrategy.rebindToPlayer(player);\n        }\n    }\n\n    /**\n     * detectSkipSegmentsAsync\n     * FUNCTION: Starts the detection process on a background thread.\n     * @param mediaIdentifier Input data for the strategies.\n     * @param callback The interface to return the result to (MainActivity).\n     */\n    public void detectSkipSegmentsAsync(MediaIdentifier mediaIdentifier, SkipDetectionCallback callback) {\n        // # Run the entire detection logic on a background thread\n        executorService.submit(() -> {\n            SkipDetectionResult result = detectSkipSegmentsSync(mediaIdentifier);\n\n            // # Post the final result back to the main UI thread\n            mainHandler.post(() -> {\n                if (result.isSuccess()) {\n                    callback.onDetectionComplete(result);\n                } else {\n                    callback.onDetectionFailed(result.getErrorMessage());\n                }\n            });\n        });\n    }\n\n    /**\n     * detectSkipSegmentsSync\n     * FUNCTION: The core, synchronous (blocking) detection logic.\n     * This runs on the background thread.\n     */\n    private SkipDetectionResult detectSkipSegmentsSync(MediaIdentifier mediaIdentifier) {\n\n        // # 1. Check Cache First\n        SkipDetectionResult cachedResult = cacheStrategy.detect(mediaIdentifier);\n        if (cachedResult.isSuccess()) {\n            Log.i(TAG, \"Cache hit: Returning result from \" + cachedResult.getSource().getDisplayName());\n            return cachedResult;\n        }\n        Log.i(TAG, \"Cache miss. Starting fresh detection.\");\n\n        // # Clear any old chapter data before starting\n        chapterStrategy.clearCapturedChapters();\n\n        // # Variables to hold the best result and its strategy priority\n        final AtomicReference<SkipDetectionResult> bestResult = new AtomicReference<>(null);\n        final AtomicReference<Integer> bestPriority = new AtomicReference<>(0);\n        final List<Future<?>> futures = new ArrayList<>();\n\n        // # 2. Run all strategies concurrently\n        for (SkipDetectionStrategy strategy : strategies) {\n            if (!strategy.isAvailable()) {\n                Log.d(TAG, \"Skipping unavailable strategy: \" + strategy.getStrategyName());\n                continue; \n            }\n\n            // # Submit each strategy to be run on the thread pool\n            Future<?> future = executorService.submit(() -> {\n                try {\n                    Log.d(TAG, \"Starting detection: \" + strategy.getStrategyName());\n                    SkipDetectionResult result = strategy.detect(mediaIdentifier);\n\n                    if (result.isSuccess()) {\n                        int strategyPriority = strategy.getPriority();\n                        Log.i(TAG, \"Success from \" + strategy.getStrategyName() + \n                              \" (Tier: \" + strategyPriority + \", Conf: \" + result.getConfidence() + \")\");\n\n                        // # Critical Section: Only one thread can update the best result\n                        synchronized (bestResult) {\n                            SkipDetectionResult current = bestResult.get();\n                            Integer currentPriority = bestPriority.get();\n                            \n                            // # TIERED SELECTION LOGIC:\n                            // # 1. If no result yet, use this one\n                            // # 2. If new strategy has HIGHER tier (priority), it wins regardless of confidence\n                            // # 3. If same tier, higher confidence wins\n                            boolean shouldReplace = false;\n                            \n                            if (current == null) {\n                                shouldReplace = true;\n                            } else if (strategyPriority > currentPriority) {\n                                // # Higher tier always wins\n                                shouldReplace = true;\n                                Log.i(TAG, \"Higher tier wins: \" + strategy.getStrategyName() + \n                                      \" (Tier \" + strategyPriority + \") beats (Tier \" + currentPriority + \")\");\n                            } else if (strategyPriority == currentPriority && \n                                      result.getConfidence() > current.getConfidence()) {\n                                // # Same tier, higher confidence wins\n                                shouldReplace = true;\n                                Log.i(TAG, \"Same tier, higher confidence wins: \" + strategy.getStrategyName());\n                            }\n                            \n                            if (shouldReplace) {\n                                bestResult.set(result);\n                                bestPriority.set(strategyPriority);\n                                Log.i(TAG, \"New best result set by \" + strategy.getStrategyName());\n                            }\n                        }\n                    } else {\n                         Log.d(TAG, \"Failed: \" + strategy.getStrategyName() + \" (\" + result.getErrorMessage() + \")\");\n                    }\n                } catch (Exception e) {\n                    Log.e(TAG, \"Error in strategy \" + strategy.getStrategyName(), e);\n                }\n            });\n\n            futures.add(future);\n        }\n\n        // # 3. Wait for all threads to complete or timeout\n        long startTime = System.currentTimeMillis();\n        boolean allDone = false;\n        while (!allDone && (System.currentTimeMillis() - startTime) < DETECTION_TIMEOUT_MS) {\n            allDone = true;\n            for (Future<?> future : futures) {\n                if (!future.isDone()) {\n                    allDone = false;\n                    break;\n                }\n            }\n            if (!allDone) {\n                try {\n                    Thread.sleep(100); // # Wait 100ms before checking again\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    break;\n                }\n            }\n        }\n\n        // # 4. Cancel any remaining running threads (if timeout was hit)\n        if (!allDone) {\n            Log.w(TAG, \"Detection timed out. Cancelling remaining strategies.\");\n            for (Future<?> future : futures) {\n                if (!future.isDone()) {\n                    future.cancel(true); // # Interrupt the running thread\n                }\n            }\n        }\n\n        // # 5. Final Result Determination with Tiered Priority System\n        // # FIX: Select winner based on TIER (priority) first, then confidence\n        SkipDetectionResult finalResult = selectBestResultByTier(bestResult.get());\n\n        // # If no strategy succeeded, create a 'failed' result\n        if (finalResult == null) {\n            Log.w(TAG, \"No strategy returned a successful result.\");\n            // # FIX: This line now compiles due to the new import\n            finalResult = SkipDetectionResult.failed(DetectionSource.NONE, \"No skip segments found by any strategy.\");\n        }\n\n        // # 6. Cache the best result (even if it's a 'failed' result)\n        cacheStrategy.cacheResult(mediaIdentifier, finalResult);\n\n        return finalResult;\n    }\n\n    /**\n     * selectBestResultByTier\n     * FUNCTION: Pass-through method - tier selection now happens in concurrent section.\n     * FIX: The tiered selection logic has been moved to the concurrent execution loop\n     *      where each result is compared by tier first, then confidence.\n     * \n     * @param currentBest The result selected by tier-aware logic\n     * @return The final result (already tier-selected)\n     */\n    private SkipDetectionResult selectBestResultByTier(SkipDetectionResult currentBest) {\n        // # The tier-based selection now happens in the concurrent section above,\n        // # so this method just passes through the already-selected best result.\n        return currentBest;\n    }\n\n    // # Public methods for cache management from Settings\n    public void clearCache() {\n        cacheStrategy.clearCache();\n    }\n\n    public void invalidateCache(MediaIdentifier mediaIdentifier) {\n        cacheStrategy.invalidateCache(mediaIdentifier);\n    }\n\n    // # Clean shutdown of the thread pool\n    public void shutdown() {\n        executorService.shutdownNow();\n    }\n}","size_bytes":14222},"EXTERNAL_PLAYER.md":{"content":"# Using TV Player as External Video Player\n\nTV Player can be launched as an external video player from streaming apps like Stremio and Syncler on Android TV.\n\n## How It Works\n\nWhen another app wants to play a video, it can send an `ACTION_VIEW` intent with the video URL. TV Player will:\n1. Receive the intent\n2. Validate the video URL (must be http:// or https://)\n3. Start playback with the provided URL\n4. Apply skip functionality if markers are available\n\n## Supported Apps\n\n### Stremio\n1. Install TV Player on your Android TV\n2. In Stremio, select a movie or episode\n3. When playback starts or in settings, choose \"External Player\"\n4. Select \"TV Player\" from the list\n5. Video plays with intro/credits skip functionality\n\n### Syncler\n1. Install TV Player on your Android TV\n2. In Syncler, navigate to a video\n3. Long-press or use menu to select \"Play with\"\n4. Choose \"TV Player\"\n5. Enjoy playback with smart skip features\n\n### Other Apps\nAny Android app that supports external video players can use TV Player. The app must:\n- Send an `ACTION_VIEW` intent\n- Include a valid http:// or https:// video URL\n- Use one of these methods:\n  - `intent.setData(Uri)` - Preferred method\n  - `intent.putExtra(Intent.EXTRA_STREAM, Uri)` - Alternate method\n\n## Supported URL Schemes\n\n- `http://` - Standard HTTP streaming\n- `https://` - Secure HTTPS streaming\n\n**Not supported**: file://, content://, rtsp://, or other custom schemes\n\n## Error Handling\n\nIf TV Player receives an invalid intent:\n- Shows error message: \"No valid video URL provided\"\n- Closes gracefully\n- Does not play default video\n\nThis ensures you always know when something goes wrong.\n\n## Skip Functionality with External Videos\n\nWhen launched as external player:\n- Auto-skip intro works if API provides markers\n- Skip Intro button appears during intro range\n- Skip Credits button appears during credits range\n- All features work exactly as standalone mode\n\n## Technical Details\n\n### Manifest Configuration\n```xml\n<intent-filter>\n    <action android:name=\"android.intent.action.VIEW\" />\n    <category android:name=\"android.intent.category.DEFAULT\" />\n    <category android:name=\"android.intent.category.BROWSABLE\" />\n    <data android:mimeType=\"video/*\" />\n    <data android:scheme=\"http\" />\n    <data android:scheme=\"https\" />\n</intent-filter>\n```\n\n### Intent Data Priority\n1. First checks `intent.getData()`\n2. Then checks `Intent.EXTRA_STREAM`\n3. If neither valid, shows error and exits\n\n## Troubleshooting\n\n**TV Player doesn't appear in external player list:**\n- Ensure app is installed on Android TV\n- Check that the streaming app supports external players\n- Try restarting the streaming app\n\n**Video won't play:**\n- Verify URL is http:// or https://\n- Check internet connection\n- Ensure video format is supported by ExoPlayer\n\n**Skip buttons don't appear:**\n- Check that MARKERS_API_URL is configured in MainActivity.java\n- Verify API returns valid JSON with intro/credits timestamps\n- API must be accessible from your network\n\n## API Configuration\n\nTo enable skip functionality for external videos, configure the API endpoint:\n\nEdit `app/src/main/java/com/tvplayer/app/MainActivity.java`:\n```java\nprivate static final String MARKERS_API_URL = \"https://your-api.com/skip-markers.json\";\n```\n\nYour API should return:\n```json\n{\n  \"intro\": { \"start\": 0, \"end\": 90 },\n  \"credits\": { \"start\": 2500, \"end\": 2700 }\n}\n```\n\nAll timestamps in seconds.\n\n## Privacy & Security\n\n- No video URLs are logged or stored\n- No data sent to external servers (except markers API if configured)\n- App only validates URL scheme (http/https)\n- Closes immediately if invalid URL detected\n\n## Limitations\n\n- Only supports http/https streaming URLs\n- Cannot play local files (file://)\n- Cannot access device storage (content://)\n- Requires network connection for streaming\n- Skip markers API must be configured manually\n\n## Best Practices\n\n1. **Test First**: Try with default video URL before using as external player\n2. **Configure API**: Set up markers API for best experience\n3. **Network**: Ensure stable connection for smooth playback\n4. **Remote**: Keep Android TV remote nearby for skip buttons\n","size_bytes":4141},"replit.md":{"content":"# TV Player - Android TV App\n\n## Overview\nAn Android TV application built with ExoPlayer that provides intelligent intro and credits skipping functionality. The app can be used as a standalone player or launched as an external video player from apps like Stremio and Syncler. It fetches skip markers from a remote API and automatically handles video navigation.\n\n## Features\n- **Fullscreen Video Playback**: ExoPlayer-based media player with fullscreen PlayerView\n- **Remote API Integration**: Fetches intro/credits timestamps from JSON API\n- **Auto-Skip Intro**: Automatically seeks past intro when playback starts\n- **Skip Intro Button**: Appears during intro range, seeks to intro end on click\n- **Skip Credits Button**: Appears during credits range, seeks to video end on click\n- **Android TV Optimized**: D-pad navigation support, LEANBACK launcher configuration\n\n## Project Structure\n```\napp/\n├── src/main/\n│   ├── java/com/tvplayer/app/\n│   │   ├── MainActivity.java          # Main activity with ExoPlayer\n│   │   ├── ApiService.java            # HTTP client for API calls\n│   │   └── SkipMarkers.java           # Data model for skip markers\n│   ├── res/\n│   │   ├── layout/\n│   │   │   └── activity_main.xml      # Fullscreen player layout\n│   │   ├── values/\n│   │   │   ├── styles.xml             # Fullscreen theme\n│   │   │   └── colors.xml             # App colors\n│   │   └── drawable/\n│   │       └── ic_launcher_foreground.xml\n│   └── AndroidManifest.xml            # LEANBACK, INTERNET permissions\n└── build.gradle                        # ExoPlayer, OkHttp, Gson dependencies\n```\n\n## API Format\nThe app expects a JSON response in this format:\n```json\n{\n  \"intro\": {\n    \"start\": 0,\n    \"end\": 90\n  },\n  \"credits\": {\n    \"start\": 2500,\n    \"end\": 2700\n  }\n}\n```\n\n## Dependencies\n- ExoPlayer 2.19.1 - Video playback\n- AndroidX Leanback 1.0.0 - TV UI support\n- OkHttp 4.11.0 - HTTP client\n- Gson 2.10.1 - JSON parsing\n\n## Configuration\nEdit `MainActivity.java` to set:\n- `VIDEO_URL`: Your video source URL\n- `MARKERS_API_URL`: Your skip markers API endpoint\n\n## Recent Changes\n- 2025-10-27: Initial project creation with ExoPlayer integration, skip functionality, and Android TV support\n- 2025-10-27: Fixed auto-skip intro to trigger when markers load (async API timing fix)\n- 2025-10-27: Fixed Skip Intro button to hide after auto-skip occurs\n- 2025-10-27: Removed duplicate auto-skip logic to prevent repeated seeks\n- 2025-10-27: Added external video player support for Stremio/Syncler integration\n- 2025-10-27: Implemented intent validation and graceful error handling for external launches\n\n## User Preferences\nNone yet\n","size_bytes":2782},"app/src/main/java/com/tvplayer/app/skipdetection/SkipDetectionStrategy.java":{"content":"package com.tvplayer.app.skipdetection;\n\npublic interface SkipDetectionStrategy {\n\n    SkipDetectionResult detect(MediaIdentifier mediaIdentifier);\n\n    String getStrategyName();\n\n    boolean isAvailable();\n\n    int getPriority();\n}","size_bytes":232},"app/src/main/java/com/tvplayer/app/MainActivity.java":{"content":"package com.tvplayer.app;\n\n// # Standard Android framework imports\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Looper;\nimport android.util.Log;\nimport android.view.KeyEvent; \nimport android.view.MotionEvent; \nimport android.view.View;\nimport android.view.WindowManager;\nimport android.widget.Button;\nimport android.widget.ImageButton;\nimport android.widget.ProgressBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\n// # AndroidX/AppCompat (UI and compatibility support)\nimport androidx.appcompat.app.AppCompatActivity;\n\n// # Media3/ExoPlayer imports for video playback\nimport androidx.media3.common.MediaItem;\nimport androidx.media3.common.PlaybackException;\nimport androidx.media3.common.Player;\nimport androidx.media3.common.TrackSelectionParameters;\nimport androidx.media3.exoplayer.ExoPlayer;\nimport androidx.media3.ui.PlayerView;\n\n// # Java standard utility imports for time/date formatting\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\n// # Smart Skip Detection imports\nimport com.tvplayer.app.skipdetection.SmartSkipManager;\nimport com.tvplayer.app.skipdetection.MediaIdentifier;\nimport com.tvplayer.app.skipdetection.SkipDetectionCallback;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegment;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegmentType;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.DetectionSource;\n\n/**\n * MainActivity\n * FUNCTION: The main video player activity. Manages player state, UI overlays,\n * controls, and coordinates the skip detection logic.\n * INTERACTS WITH:\n * - activity_main.xml (The layout)\n * - styles.xml / colors.xml (Styling)\n * - PreferencesHelper.java (Loading settings)\n * - SmartSkipManager.java (Running skip detection)\n * - SkipMarkers.java (Holding the active skip times)\n * - SettingsActivity.java (Launching the settings page)\n */\npublic class MainActivity extends AppCompatActivity implements Player.Listener, SkipDetectionCallback {\n\n    private static final String TAG = \"MainActivity\";\n\n    // --- Core Media Player Components ---\n    private PlayerView playerView;\n    private ExoPlayer player;\n\n    // --- UI/Control Components ---\n    private View customControls; // # ID: customControlsOverlay\n    private View skipButtonsOverlayContainer; // # Container for all skip buttons\n    private Handler controlsHandler = new Handler(Looper.getMainLooper());\n    private static final int CONTROLS_TIMEOUT_MS = 5000;\n    private ImageButton btnPlayPause, btnSettings, btnRewind, btnFastForward;\n    private TextView tvCurrentTime, tvTotalTime, tvRemainingTime, tvFinishTime;\n    private ProgressBar progressBar;\n\n    // --- Skip Button Components ---\n    private Button btnSkipIntro, btnSkipRecap, btnSkipCredits, btnNextEpisode;\n    private Button btnSkipCancel; // # NEW: Cancel Button (Feature P2/Cancel)\n\n    // --- Time/Scrubbing State ---\n    private Handler timeUpdateHandler = new Handler(Looper.getMainLooper());\n    private static final int SCRUB_INTERVAL_MS = 250; \n    private static final int SCRUB_STEP_MS = 5000;\n    private int scrubMultiplier = 0; // # 0 = not scrubbing\n\n    // --- Custom Logic Helpers ---\n    private PreferencesHelper preferencesHelper;\n    private SkipMarkers skipMarkers;\n    private SmartSkipManager smartSkipManager;\n\n    // --- Time Formatting ---\n    private final SimpleDateFormat durationFormat;\n    private final SimpleDateFormat finishTimeFormat = new SimpleDateFormat(\"h:mm a\", Locale.getDefault());\n\n    // --- Runnables ---\n\n    // # Runnable to hide controls after a timeout\n    private final Runnable controlsTimeoutRunnable = new Runnable() {\n        @Override\n        public void run() {\n            hideControls();\n        }\n    };\n\n    /**\n     * Runnable that updates all time displays and the progress bar every second.\n     */\n    private final Runnable timeUpdateRunnable = new Runnable() {\n        @Override\n        public void run() {\n            if (player != null && (player.getPlaybackState() == Player.STATE_READY || player.getPlaybackState() == Player.STATE_BUFFERING) && player.isPlaying()) {\n                updateProgress();\n            }\n            // # Reschedule the runnable to run again in 1 second\n            timeUpdateHandler.postDelayed(this, 1000); \n        }\n    };\n\n    /**\n     * Runnable for handling fast-scrubbing (FF/RW).\n     */\n    private final Runnable scrubRunnable = new Runnable() {\n        @Override\n        public void run() {\n            if (player != null && scrubMultiplier != 0) {\n                long seekAmount = (long) scrubMultiplier * SCRUB_STEP_MS;\n                long newPosition = player.getCurrentPosition() + seekAmount;\n                // # Clamp position to valid range\n                newPosition = Math.max(0, Math.min(newPosition, player.getDuration()));\n                player.seekTo(newPosition);\n\n                updateProgress(); // # Update time display immediately\n                resetControlsTimeout(); // # Keep the controls visible\n\n                // # Reschedule for the next seek tick\n                timeUpdateHandler.postDelayed(this, SCRUB_INTERVAL_MS);\n            }\n        }\n    };\n\n\n    /**\n     * Constructor\n     * FUNCTION: Initializes the time formatter for durations.\n     */\n    public MainActivity() {\n        super();\n        // # This formatter will correctly show \"00:30:00\" instead of \"30:00\"\n        durationFormat = new SimpleDateFormat(\"HH:mm:ss\", Locale.getDefault());\n        durationFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n    }\n\n    // =========================================================================\n    // LIFECYCLE METHODS\n    // =========================================================================\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        // # Ensure the screen remains on while the activity is running\n        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n        setContentView(R.layout.activity_main);\n\n        // # 1. Initialize helper classes\n        preferencesHelper = new PreferencesHelper(this);\n        skipMarkers = new SkipMarkers();\n        // # Initialize SmartSkipManager *without* the Player.\n        smartSkipManager = new SmartSkipManager(this, preferencesHelper);\n\n        // # 2. Map UI elements to their IDs\n        initializeViews();\n\n        // # 3. Set up the ExoPlayer instance\n        initializePlayer();\n\n        // # 4. Handle incoming intent (e.g., being launched from Stremio)\n        handleIntent(getIntent());\n    }\n\n    @Override\n    protected void onNewIntent(Intent intent) {\n        super.onNewIntent(intent);\n        setIntent(intent); // # Update the activity's intent\n\n        // # Release the old player and create a new one for the new media\n        releasePlayer();\n        initializePlayer();\n        handleIntent(intent);\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        // # Start the time update loop\n        timeUpdateHandler.post(timeUpdateRunnable);\n        // # Load preferences in case they were changed in SettingsActivity\n        loadPreferencesAndApply();\n        // # Resume playback if the player exists\n        if (player != null) {\n            player.play();\n        }\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n        // # Stop the time update loop when the activity is not visible\n        timeUpdateHandler.removeCallbacks(timeUpdateRunnable);\n        // # Pause playback\n        if (player != null) {\n            player.pause();\n        }\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        // # Release all resources\n        releasePlayer();\n        if (smartSkipManager != null) {\n            smartSkipManager.shutdown();\n        }\n        controlsHandler.removeCallbacks(controlsTimeoutRunnable);\n        timeUpdateHandler.removeCallbacks(timeUpdateRunnable);\n        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n    }\n\n    // =========================================================================\n    // INITIALIZATION & MEDIA HANDLING\n    // =========================================================================\n\n    /**\n     * Finds and initializes all view components from activity_main.xml.\n     * Interacts with: activity_main.xml\n     */\n    private void initializeViews() {\n        playerView = findViewById(R.id.playerView);\n\n        // # ID: customControlsOverlay\n        customControls = findViewById(R.id.customControlsOverlay); \n        skipButtonsOverlayContainer = findViewById(R.id.skipButtonsOverlayContainer);\n\n        // # Time Info\n        tvCurrentTime = findViewById(R.id.tvCurrentTime);\n        tvTotalTime = findViewById(R.id.tvTotalTime);\n        tvRemainingTime = findViewById(R.id.tvRemainingTime);\n        tvFinishTime = findViewById(R.id.tvFinishTime);\n        progressBar = findViewById(R.id.progressBar);\n\n        // # Control Buttons\n        btnPlayPause = findViewById(R.id.btnPlayPause);\n        btnSettings = findViewById(R.id.btnSettings);\n        btnRewind = findViewById(R.id.btnRewind);\n        btnFastForward = findViewById(R.id.btnFastForward);\n\n        // # Skip Buttons\n        btnSkipIntro = findViewById(R.id.btnSkipIntro);\n        btnSkipRecap = findViewById(R.id.btnSkipRecap);\n        btnSkipCredits = findViewById(R.id.btnSkipCredits);\n        btnNextEpisode = findViewById(R.id.btnNextEpisode);\n        btnSkipCancel = findViewById(R.id.btnSkipCancel); // # NEW: Find cancel button\n\n        // # Set click listeners for controls\n        setupControlListeners();\n\n        // # Set click listeners for skip buttons\n        setupSkipButtonListeners();\n\n        // # Hide controls initially\n        hideControls();\n    }\n\n    /**\n     * Sets click listeners for all playback controls.\n     */\n    private void setupControlListeners() {\n        // # Player view itself toggles controls\n        playerView.setOnClickListener(v -> toggleControls());\n\n        // # Playback controls\n        btnPlayPause.setOnClickListener(v -> {\n            if (player != null) player.setPlayWhenReady(!player.getPlayWhenReady());\n            resetControlsTimeout();\n        });\n        btnRewind.setOnClickListener(v -> {\n            if (player != null) player.seekTo(player.getCurrentPosition() - 10000); // # 10 sec\n            resetControlsTimeout();\n        });\n        btnFastForward.setOnClickListener(v -> {\n            if (player != null) player.seekTo(player.getCurrentPosition() + 10000); // # 10 sec\n            resetControlsTimeout();\n        });\n\n        // # Settings button\n        btnSettings.setOnClickListener(v -> {\n            Intent intent = new Intent(MainActivity.this, SettingsActivity.class);\n            startActivity(intent);\n            resetControlsTimeout();\n        });\n\n        // # Placeholder button listeners for other controls\n        findViewById(R.id.btnAudioDelay).setOnClickListener(v -> Toast.makeText(this, \"Audio Delay Not Implemented\", Toast.LENGTH_SHORT).show());\n        findViewById(R.id.btnSubtitleDelay).setOnClickListener(v -> Toast.makeText(this, \"Subtitle Delay Not Implemented\", Toast.LENGTH_SHORT).show());\n        findViewById(R.id.btnSubtitles).setOnClickListener(v -> Toast.makeText(this, \"Subtitles Not Implemented\", Toast.LENGTH_SHORT).show());\n        findViewById(R.id.btnPlaybackSpeed).setOnClickListener(v -> Toast.makeText(this, \"Speed Not Implemented\", Toast.LENGTH_SHORT).show());\n    }\n\n    /**\n     * Sets click listeners for all skip-related buttons.\n     */\n    private void setupSkipButtonListeners() {\n        btnSkipIntro.setOnClickListener(v -> performSkip(SkipSegmentType.INTRO));\n        btnSkipRecap.setOnClickListener(v -> performSkip(SkipSegmentType.RECAP));\n        btnSkipCredits.setOnClickListener(v -> performSkip(SkipSegmentType.CREDITS));\n        btnNextEpisode.setOnClickListener(v -> performSkip(SkipSegmentType.NEXT_EPISODE)); \n\n        // # NEW: Cancel button hides the skip overlay\n        btnSkipCancel.setOnClickListener(v -> {\n            hideSkipButtons();\n            // # Briefly show main controls so user knows action was registered\n            showControls(); \n        });\n    }\n\n    /**\n     * Creates and configures the ExoPlayer instance.\n     * Interacts with: Media3/ExoPlayer library\n     */\n    private void initializePlayer() {\n        if (player == null) {\n            player = new ExoPlayer.Builder(this).build();\n            player.addListener(this);\n            playerView.setPlayer(player);\n        }\n    }\n\n    /**\n     * Releases the ExoPlayer resources.\n     */\n    private void releasePlayer() {\n        if (player != null) {\n            player.removeListener(this); // # Important: remove listener\n            player.release();\n            player = null;\n        }\n    }\n\n    /**\n     * Handles incoming Intents, typically a VIEW intent for a media URI.\n     * @param intent The intent that started the activity.\n     */\n    private void handleIntent(Intent intent) {\n        Uri uri = intent.getData();\n        if (uri != null && player != null) {\n            Log.i(TAG, \"Handling new media intent: \" + uri.toString());\n            MediaItem mediaItem = MediaItem.fromUri(uri);\n            player.setMediaItem(mediaItem);\n            player.prepare();\n            player.play();\n        } else {\n            Log.w(TAG, \"Intent was null or had no data. Player not started.\");\n        }\n    }\n\n    /**\n     * Loads settings from PreferencesHelper and applies them to the player.\n     * Interacts with: PreferencesHelper.java\n     */\n    private void loadPreferencesAndApply() {\n        if (player == null) return;\n\n        // # Load manual markers into our SkipMarkers object\n        skipMarkers.setIntro(preferencesHelper.getIntroStart(), preferencesHelper.getIntroEnd());\n        skipMarkers.setRecap(preferencesHelper.getRecapStart(), preferencesHelper.getRecapEnd());\n\n        // # Note: Credits \"start\" is an offset from the end\n        long durationSec = player.getDuration() / 1000;\n        int creditsOffset = preferencesHelper.getCreditsStart();\n        if (creditsOffset > 0 && durationSec > 0) {\n            skipMarkers.setCredits((int)(durationSec - creditsOffset), (int)durationSec);\n        } else {\n             // # This is a fallback if offset isn't set but manual end time is\n            skipMarkers.setCredits(0, preferencesHelper.getCreditsEnd()); \n        }\n\n        skipMarkers.setNextEpisodeStart(preferencesHelper.getNextEpisodeStart());\n\n        // # Apply Subtitle Delay\n        // # FIX: This method (`setSubtitleDelay`) is now available because\n        // # we updated the media3 library version in build.gradle\n        try {\n            int subtitleDelayMs = preferencesHelper.getSubtitleDelayMs();\n            player.setSubtitleDelay((long) subtitleDelayMs); // # This is the correct method\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to apply subtitle delay\", e);\n        }\n    }\n\n    /**\n     * Initiates the Smart Skip detection process for the current media.\n     * This is called once the player is ready.\n     */\n    private void startSkipDetection() {\n        if (player == null || player.getDuration() <= 0) return;\n\n        // # Pass the (now ready) player to the manager\n        smartSkipManager.rebindPlayer(player);\n\n        // # Create the MediaIdentifier with all known info\n        MediaIdentifier mediaIdentifier = new MediaIdentifier.Builder()\n            .setTitle(player.getMediaMetadata().title != null ? player.getMediaMetadata().title.toString() : \"Unknown\")\n            .setRuntimeSeconds(player.getDuration() / 1000)\n            // # TODO: Add Trakt/TMDB/TVDB IDs here when available\n            // .setTraktId(\"...\")\n            // .setTmdbId(\"...\")\n            // .setSeasonNumber(1)\n            // .setEpisodeNumber(1)\n            .build();\n\n        // # Start the async detection. 'this' (MainActivity) is the callback.\n        smartSkipManager.detectSkipSegmentsAsync(mediaIdentifier, this);\n    }\n\n    // =========================================================================\n    // PLAYER EVENT HANDLING (Player.Listener)\n    // =========================================================================\n\n    @Override\n    public void onIsPlayingChanged(boolean isPlaying) {\n        // # Update the play/pause button icon\n        updatePlayPauseButton();\n    }\n\n    @Override\n    public void onPlaybackStateChanged(int playbackState) {\n        if (playbackState == Player.STATE_READY) {\n            Log.i(TAG, \"Player is READY.\");\n            // # Player is ready, load settings\n            loadPreferencesAndApply();\n            // # Start the progress bar update loop\n            timeUpdateHandler.post(timeUpdateRunnable);\n            // # Start the skip detection process\n            startSkipDetection();\n\n        } else if (playbackState == Player.STATE_ENDED) {\n            Log.i(TAG, \"Player has ENDED.\");\n            finish(); // # Close the activity when the video finishes\n\n        } else if (playbackState == Player.STATE_BUFFERING) {\n            Log.d(TAG, \"Player is BUFFERING.\");\n\n        } else if (playbackState == Player.STATE_IDLE) {\n            Log.d(TAG, \"Player is IDLE.\");\n        }\n    }\n\n    @Override\n    public void onPlayerError(PlaybackException error) {\n        // # Shows an alert dialog on playback error\n        Log.e(TAG, \"Player Error\", error);\n        new AlertDialog.Builder(this)\n                .setTitle(\"Playback Error\")\n                .setMessage(error.getMessage())\n                .setPositiveButton(android.R.string.ok, (dialog, which) -> finish())\n                .show();\n    }\n\n    // =========================================================================\n    // SMART SKIP CALLBACKS (SkipDetectionCallback)\n    // =========================================================================\n\n    /**\n     * Called by SmartSkipManager when a skip segment result is successfully found.\n     * This runs on the MAIN THREAD.\n     * Interacts with: SmartSkipManager.java, SkipMarkers.java\n     */\n    @Override\n    public void onDetectionComplete(SkipDetectionResult result) {\n        if (result.isSuccess()) {\n            // # Use getDisplayName() which now exists\n            Log.i(TAG, \"Skip detection success from: \" + result.getSource().getDisplayName());\n            Toast.makeText(this, \"Skip markers found via \" + result.getSource().getDisplayName(), Toast.LENGTH_SHORT).show();\n\n            // # Clear manual markers and apply the new, better ones\n            skipMarkers.clearAll();\n            for (SkipSegment segment : result.getSegments()) {\n                if (segment.type == SkipSegmentType.INTRO) {\n                    skipMarkers.setIntro(segment.startSeconds, segment.endSeconds);\n                } else if (segment.type == SkipSegmentType.RECAP) {\n                    skipMarkers.setRecap(segment.startSeconds, segment.endSeconds);\n                } else if (segment.type == SkipSegmentType.CREDITS) {\n                    skipMarkers.setCredits(segment.startSeconds, segment.endSeconds);\n                } else if (segment.type == SkipSegmentType.NEXT_EPISODE) {\n                    skipMarkers.setNextEpisodeStart(segment.startSeconds);\n                }\n            }\n        } else {\n            // # On failure, we just keep the manual preferences that were already loaded\n            Log.w(TAG, \"Skip detection failed: \" + result.getErrorMessage() + \". Using manual preferences.\");\n            Toast.makeText(this, \"Skip detection failed. Using manual settings.\", Toast.LENGTH_LONG).show();\n        }\n\n        // # Do an initial check to show buttons if we're already in a segment\n        updateSkipButtonVisibility();\n        // # Check for auto-skip\n        performAutoSkip();\n    }\n\n    /**\n     * Called by SmartSkipManager on a critical failure.\n     * This runs on the MAIN THREAD.\n     */\n    @Override\n    public void onDetectionFailed(String errorMessage) {\n        // # On critical failure, just use manual preferences\n        Log.e(TAG, \"Critical skip detection failure: \" + errorMessage);\n        Toast.makeText(this, \"Skip detection error. Using manual settings.\", Toast.LENGTH_LONG).show();\n        loadPreferencesAndApply();\n        updateSkipButtonVisibility();\n    }\n\n    // =========================================================================\n    // SKIP LOGIC & ACTIONS\n    // =========================================================================\n\n    /**\n     * Hides all skip-related buttons and the overlay container.\n     * Called when a skip is performed or 'Cancel' is pressed.\n     * (Feature P2/Cancel)\n     */\n    private void hideSkipButtons() {\n        skipButtonsOverlayContainer.setVisibility(View.GONE);\n        btnSkipIntro.setVisibility(View.GONE);\n        btnSkipRecap.setVisibility(View.GONE);\n        btnSkipCredits.setVisibility(View.GONE);\n        btnNextEpisode.setVisibility(View.GONE);\n        btnSkipCancel.setVisibility(View.GONE);\n\n        // # Return focus to the player view to prevent a \"lost focus\" state\n        if(playerView != null) {\n            playerView.requestFocus();\n        }\n    }\n\n    /**\n     * Manages visibility and focus of all skip buttons.\n     * Implements priority (Intro > Recap > Credits) (Feature P1).\n     * Implements focus-fix (Feature P2/Focus).\n     * This is called every second by the timeUpdateRunnable.\n     */\n    private void updateSkipButtonVisibility() {\n        if (player == null || skipMarkers == null) return;\n\n        long currentPositionSec = player.getCurrentPosition() / 1000;\n\n        // # Check which segments are active\n        boolean inIntro = skipMarkers.isInIntro(currentPositionSec);\n        boolean inRecap = skipMarkers.isInRecap(currentPositionSec);\n        boolean inCredits = skipMarkers.isInCredits(currentPositionSec);\n        boolean atNextEp = skipMarkers.isAtNextEpisode(currentPositionSec);\n\n        // # Reset visibility\n        btnSkipIntro.setVisibility(View.GONE);\n        btnSkipRecap.setVisibility(View.GONE);\n        btnSkipCredits.setVisibility(View.GONE);\n        btnNextEpisode.setVisibility(View.GONE);\n        btnSkipCancel.setVisibility(View.GONE); // # Also hide cancel\n\n        Button buttonToFocus = null;\n\n        // --- PRIORITY LOGIC (Feature P1) ---\n        // # Only show ONE skip button at a time, in this order:\n        if (inIntro) {\n            btnSkipIntro.setVisibility(View.VISIBLE);\n            buttonToFocus = btnSkipIntro;\n        } else if (inRecap) {\n            btnSkipRecap.setVisibility(View.VISIBLE);\n            buttonToFocus = btnSkipRecap;\n        } else if (inCredits) {\n            btnSkipCredits.setVisibility(View.VISIBLE);\n            buttonToFocus = btnSkipCredits;\n        }\n\n        // # Next Episode button can show alongside Credits\n        if (atNextEp) {\n            btnNextEpisode.setVisibility(View.VISIBLE);\n            if (buttonToFocus == null) { // # Focus NextEp if no other button is active\n                buttonToFocus = btnNextEpisode;\n            }\n        }\n\n        // --- FOCUS & CANCEL BUTTON LOGIC (Feature P2) ---\n        if (buttonToFocus != null) {\n            // # If any button is visible, show the container and the Cancel button\n            skipButtonsOverlayContainer.setVisibility(View.VISIBLE);\n            btnSkipCancel.setVisibility(View.VISIBLE);\n\n            // # FOCUS FIX: Request focus on the highest-priority button\n            // # This check prevents stealing focus if the user is using the main controls\n            if (!customControls.isShown() && !skipButtonsOverlayContainer.hasFocus()) {\n                 buttonToFocus.requestFocus();\n            }\n        } else if (skipButtonsOverlayContainer.isShown()) {\n            // # No buttons are active, hide the container\n            hideSkipButtons();\n        }\n    }\n\n    /**\n     * Performs a seek operation based on the requested skip type.\n     * @param type The type of segment to skip (INTRO, RECAP, etc.).\n     */\n    private void performSkip(SkipSegmentType type) {\n        if (player == null || skipMarkers == null) return;\n\n        long seekToMs = -1;\n        String toastMessage = \"\";\n\n        switch (type) {\n            case INTRO:\n                // # Use getIntro().end to get the TimeRange object\n                seekToMs = skipMarkers.getIntro().end * 1000L;\n                toastMessage = \"Skipping Intro\";\n                break;\n            case RECAP:\n                // # Use getRecap().end to get the TimeRange object\n                seekToMs = skipMarkers.getRecap().end * 1000L;\n                toastMessage = \"Skipping Recap\";\n                break;\n            case CREDITS:\n                // # For Credits, skip to the end of the video\n                seekToMs = player.getDuration(); \n                toastMessage = \"Skipping Credits\";\n                break;\n            case NEXT_EPISODE:\n                // # For Next Episode, seek to the end to trigger STATE_ENDED\n                seekToMs = player.getDuration();\n                toastMessage = \"Loading Next Episode...\"; // # Placeholder\n                break;\n            default:\n                return;\n        }\n\n        if (seekToMs >= 0) {\n            player.seekTo(seekToMs);\n            if (!toastMessage.isEmpty()) {\n                Toast.makeText(this, toastMessage, Toast.LENGTH_SHORT).show();\n            }\n            // # Hide buttons immediately after skip\n            hideSkipButtons();\n        }\n    }\n\n    /**\n     * Checks preferences and automatically seeks if an auto-skip is due.\n     */\n    private void performAutoSkip() {\n        if (player == null || skipMarkers == null) return;\n\n        long currentPositionSec = player.getCurrentPosition() / 1000;\n\n        // # Check Auto-Skip Intro\n        if (preferencesHelper.isAutoSkipIntro() && skipMarkers.isInIntro(currentPositionSec)) {\n            Log.i(TAG, \"Auto-skipping Intro\");\n            Toast.makeText(this, \"Auto-skipping Intro\", Toast.LENGTH_SHORT).show();\n            performSkip(SkipSegmentType.INTRO);\n            return; // # Only perform one auto-skip per check\n        }\n\n        // # Check Auto-Skip Recap\n        if (preferencesHelper.isAutoSkipRecap() && skipMarkers.isInRecap(currentPositionSec)) {\n            Log.i(TAG, \"Auto-skipping Recap\");\n            Toast.makeText(this, \"Auto-skipping Recap\", Toast.LENGTH_SHORT).show();\n            performSkip(SkipSegmentType.RECAP);\n            return;\n        }\n\n        // # Check Auto-Skip Credits\n        if (preferencesHelper.isAutoSkipCredits() && skipMarkers.isInCredits(currentPositionSec)) {\n            Log.i(TAG, \"Auto-skipping Credits\");\n            Toast.makeText(this, \"Auto-skipping Credits\", Toast.LENGTH_SHORT).show();\n            performSkip(SkipSegmentType.CREDITS);\n        }\n    }\n\n    // =========================================================================\n    // UI/CONTROL METHODS\n    // =========================================================================\n\n    /**\n     * Shows the custom control overlay and starts the auto-hide timer.\n     */\n    private void showControls() {\n        if (customControls.getVisibility() != View.VISIBLE) {\n            customControls.setVisibility(View.VISIBLE);\n            // # Request focus on the play button for D-pad control\n            btnPlayPause.requestFocus();\n        }\n        resetControlsTimeout();\n    }\n\n    /**\n     * Hides the custom control overlay.\n     */\n    private void hideControls() {\n        customControls.setVisibility(View.GONE);\n    }\n\n    /**\n     * Shows controls if hidden, or hides them if visible.\n     */\n    private void toggleControls() {\n        if (customControls.getVisibility() == View.VISIBLE) {\n            hideControls();\n        } else {\n            showControls();\n        }\n    }\n\n    /**\n     * Resets the 5-second timer before the controls auto-hide.\n     */\n    private void resetControlsTimeout() {\n        // # Use controlsTimeoutRunnable\n        controlsHandler.removeCallbacks(controlsTimeoutRunnable);\n        controlsHandler.postDelayed(controlsTimeoutRunnable, CONTROLS_TIMEOUT_MS);\n    }\n\n    /**\n     * Updates the play/pause button icon based on the player state.\n     */\n    private void updatePlayPauseButton() {\n        if (player == null) return;\n        if (player.isPlaying()) {\n            btnPlayPause.setImageResource(android.R.drawable.ic_media_pause);\n        } else {\n            btnPlayPause.setImageResource(android.R.drawable.ic_media_play);\n        }\n    }\n\n    // =========================================================================\n    // TIME & PROGRESS BAR UPDATES\n    // =========================================================================\n\n    /**\n     * Updates all time-related UI elements.\n     */\n    private void updateProgress() {\n        if (player == null || player.getDuration() <= 0) {\n            return; // # Don't update if player isn't ready\n        }\n\n        long durationMs = player.getDuration();\n        long currentPositionMs = player.getCurrentPosition();\n        long remainingMs = durationMs - currentPositionMs;\n\n        // # Update Progress Bar (max is 1000)\n        int progress = (int) ((currentPositionMs * 1000) / durationMs);\n        progressBar.setProgress(progress);\n\n        // # Update time text views using the UTC-based duration formatter\n        tvCurrentTime.setText(durationFormat.format(new Date(currentPositionMs)));\n        tvTotalTime.setText(\" / \" + durationFormat.format(new Date(durationMs)));\n        tvRemainingTime.setText(durationFormat.format(new Date(remainingMs)));\n\n        // # Update Finish At time using the system's local time zone\n        tvFinishTime.setText(finishTimeFormat.format(new Date(System.currentTimeMillis() + remainingMs)));\n\n        // # Update the skip buttons visibility\n        updateSkipButtonVisibility();\n    }\n\n    // =========================================================================\n    // KEY EVENT HANDLING (Custom Remote/D-Pad Logic)\n    // =========================================================================\n\n    /**\n     * Stops the fast-forward/rewind scrubbing action.\n     */\n    private void stopScrubbing() {\n        scrubMultiplier = 0;\n        timeUpdateHandler.removeCallbacks(scrubRunnable);\n    }\n\n    /**\n     * Main handler for all physical key presses (Remote/D-Pad).\n     */\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (player == null) return super.dispatchKeyEvent(event);\n\n        // # Show controls on ANY key press if they are hidden\n        if (event.getAction() == KeyEvent.ACTION_DOWN && !customControls.isShown()) {\n            // # Don't show controls if it's a media key that works while hidden\n            // # FIX: Changed MEDIA_PLAY to KEYCODE_MEDIA_PLAY\n            if (event.getKeyCode() != KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE &&\n                event.getKeyCode() != KeyEvent.KEYCODE_MEDIA_PLAY &&\n                event.getKeyCode() != KeyEvent.KEYCODE_MEDIA_PAUSE) {\n\n                // # Also don't show controls if a skip button is visible\n                if (!skipButtonsOverlayContainer.isShown()) {\n                    showControls();\n                }\n            }\n        }\n\n        // # Reset auto-hide timer (unless a skip button has focus)\n        if (!skipButtonsOverlayContainer.hasFocus()) {\n             resetControlsTimeout();\n        }\n\n        // --- KEY DOWN ACTION HANDLING ---\n        if (event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                // # Handle Play/Pause\n                case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:\n                // # FIX: Changed MEDIA_PLAY to KEYCODE_MEDIA_PLAY\n                case KeyEvent.KEYCODE_MEDIA_PLAY:\n                    player.play();\n                    return true;\n                case KeyEvent.KEYCODE_MEDIA_PAUSE:\n                    player.pause();\n                    return true;\n\n                // # Handle D-Pad Center / Enter\n                case KeyEvent.KEYCODE_DPAD_CENTER:\n                case KeyEvent.KEYCODE_ENTER:\n                    // # If controls are hidden AND skip buttons are hidden, toggle controls\n                    if (!customControls.isShown() && !skipButtonsOverlayContainer.isShown()) {\n                        toggleControls();\n                        return true;\n                    }\n                    // # If controls are shown, or skip buttons are shown, let system handle click\n                    return super.dispatchKeyEvent(event);\n\n                // # Handle FF/RW\n                case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (event.getRepeatCount() == 0) { // # On first press\n                        stopScrubbing();\n                        scrubMultiplier = 1;\n                        timeUpdateHandler.post(scrubRunnable);\n                    }\n                    return true;\n\n                case KeyEvent.KEYCODE_MEDIA_REWIND:\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (event.getRepeatCount() == 0) { // # On first press\n                        stopScrubbing();\n                        scrubMultiplier = -1;\n                        timeUpdateHandler.post(scrubRunnable);\n                    }\n                    return true;\n            }\n        }\n\n        // --- KEY UP ACTION HANDLING ---\n        if (event.getAction() == KeyEvent.ACTION_UP) {\n            switch (event.getKeyCode()) {\n                // # Stop scrubbing when FF/RW/D-Pad L/R is released\n                case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                case KeyEvent.KEYCODE_MEDIA_REWIND:\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    stopScrubbing();\n                    return true;\n            }\n        }\n\n        // # Fallback: let the system handle it\n        return super.dispatchKeyEvent(event);\n    }\n}","size_bytes":34267},"app/src/main/java/com/tvplayer/app/PreferencesHelper.java":{"content":"package com.tvplayer.app;\n\n// Standard Android framework imports\nimport android.content.Context;\nimport android.content.SharedPreferences;\n\n// AndroidX/Preference for getting the default preference file\nimport androidx.preference.PreferenceManager;\n\n/**\n * PreferencesHelper: A utility class to encapsulate all reading and writing\n * to the application's SharedPreferences. This makes the code in MainActivity.java\n * cleaner and centralizes all preference keys.\n *\n * Interacts with:\n * - MainActivity.java: Called to load all user settings and apply them to the player/skip logic.\n * - preferences.xml: Contains the keys and default values used here.\n */\npublic class PreferencesHelper {\n\n    // The main object used to read and write preferences\n    private final SharedPreferences prefs;\n\n    /**\n     * Constructor. Uses the default SharedPreferences file for the application.\n     * @param context The application context.\n     */\n    public PreferencesHelper(Context context) {\n        this.prefs = PreferenceManager.getDefaultSharedPreferences(context);\n    }\n\n    // --- API KEY GETTERS ---\n\n    public String getTraktApiKey() {\n        return prefs.getString(\"trakt_api_key\", \"\");\n    }\n\n    public String getTmdbApiKey() {\n        return prefs.getString(\"tmdb_api_key\", \"\");\n    }\n\n    public String getTvdbApiKey() {\n        return prefs.getString(\"tvdb_api_key\", \"\");\n    }\n\n    // --- DEBRID KEY GETTERS ---\n\n    public String getRealDebridKey() {\n        return prefs.getString(\"real_debrid_key\", \"\");\n    }\n\n    public String getTorboxKey() {\n        return prefs.getString(\"torbox_key\", \"\");\n    }\n\n    public String getAllDebridKey() {\n        return prefs.getString(\"all_debrid_key\", \"\");\n    }\n\n    // --- MANUAL SKIP TIMING GETTERS (in seconds) ---\n    // Note: EditTextPreference stores values as Strings, so we must parse them.\n\n    public int getIntroStart() {\n        return parseIntSafe(prefs.getString(\"intro_start\", \"0\"), 0);\n    }\n\n    public int getIntroEnd() {\n        return parseIntSafe(prefs.getString(\"intro_end\", \"0\"), 0);\n    }\n\n    public int getRecapStart() {\n        return parseIntSafe(prefs.getString(\"recap_start\", \"0\"), 0);\n    }\n\n    public int getRecapEnd() {\n        return parseIntSafe(prefs.getString(\"recap_end\", \"0\"), 0);\n    }\n\n    public int getCreditsStart() {\n        // This is the offset (time from end) in the settings menu\n        return parseIntSafe(prefs.getString(\"credits_start\", \"0\"), 0);\n    }\n\n    public int getCreditsEnd() {\n        return parseIntSafe(prefs.getString(\"credits_end\", \"0\"), 0);\n    }\n\n    public int getNextEpisodeStart() {\n        return parseIntSafe(prefs.getString(\"next_ep_start\", \"0\"), 0);\n    }\n\n    // --- AUTO-SKIP SETTINGS ---\n\n    public boolean isAutoSkipIntro() {\n        return prefs.getBoolean(\"auto_skip_intro\", false);\n    }\n\n    public boolean isAutoSkipRecap() {\n        return prefs.getBoolean(\"auto_skip_recap\", false);\n    }\n\n    public boolean isAutoSkipCredits() {\n        return prefs.getBoolean(\"auto_skip_credits\", false);\n    }\n\n    // --- DELAY SETTINGS (in milliseconds) ---\n\n    public int getAudioDelayMs() {\n        return parseIntSafe(prefs.getString(\"audio_delay_ms\", \"0\"), 0);\n    }\n\n    public int getSubtitleDelayMs() {\n        return parseIntSafe(prefs.getString(\"subtitle_delay_ms\", \"0\"), 0);\n    }\n\n    /**\n     * Setter for Audio Delay, for run-time adjustments (e.g., from a button press).\n     * @param delayMs The new delay in milliseconds.\n     */\n    public void setAudioDelayMs(int delayMs) {\n        prefs.edit().putString(\"audio_delay_ms\", String.valueOf(delayMs)).apply();\n    }\n\n    /**\n     * Setter for Subtitle Delay, for run-time adjustments.\n     * @param delayMs The new delay in milliseconds.\n     */\n    public void setSubtitleDelayMs(int delayMs) {\n        prefs.edit().putString(\"subtitle_delay_ms\", String.valueOf(delayMs)).apply();\n    }\n\n    /**\n     * Safely converts a String value from preferences to an integer.\n     * @param value The string from SharedPreferences.\n     * @param defaultValue The value to return if parsing fails.\n     * @return The parsed integer or the default value.\n     */\n    private int parseIntSafe(String value, int defaultValue) {\n        try {\n            return Integer.parseInt(value);\n        } catch (NumberFormatException e) {\n            return defaultValue;\n        }\n    }\n}","size_bytes":4363},"SETUP.md":{"content":"# Setup Instructions for TV Player Android App\n\n## Important Note\n\nThis is an **Android TV application** that must be built and installed on an Android TV device or emulator. It cannot run directly in the browser like a web application.\n\n## What You Have\n\nA complete Android TV app with:\n- ✅ ExoPlayer video player integration\n- ✅ Remote API integration for skip markers\n- ✅ Auto-skip intro functionality\n- ✅ Skip Intro and Skip Credits buttons\n- ✅ Android TV remote (D-pad) navigation support\n- ✅ LEANBACK launcher configuration\n- ✅ Fullscreen optimized UI\n\n## Next Steps\n\n### 1. Configure Your API and Video Source\n\nEdit `app/src/main/java/com/tvplayer/app/MainActivity.java` (lines 28-29):\n\n```java\nprivate static final String VIDEO_URL = \"https://your-video-url.com/video.mp4\";\nprivate static final String MARKERS_API_URL = \"https://your-api.com/skip-markers.json\";\n```\n\n### 2. Build the APK\n\nYou have two options:\n\n#### Option A: Build on Your Local Machine\n\n1. Install [Android Studio](https://developer.android.com/studio)\n2. Download this project\n3. Open in Android Studio\n4. Click **Build → Build Bundle(s) / APK(s) → Build APK(s)**\n5. APK will be in `app/build/outputs/apk/debug/`\n\n#### Option B: Build via Command Line\n\nIf you have Android SDK installed:\n\n```bash\n./build.sh\n```\n\nOr manually:\n\n```bash\nchmod +x gradlew\n./gradlew assembleDebug\n```\n\n### 3. Install on Android TV\n\n#### Via USB (ADB):\n\n```bash\n# Enable USB debugging on your Android TV\n# Connect via USB or network\n\nadb install app/build/outputs/apk/debug/app-debug.apk\n```\n\n#### Via Network (ADB over WiFi):\n\n```bash\n# Enable ADB debugging in Android TV Settings\n# Note your TV's IP address\n\nadb connect 192.168.1.XXX:5555\nadb install app/build/outputs/apk/debug/app-debug.apk\nadb shell am start -n com.tvplayer.app/.MainActivity\n```\n\n#### Via File Transfer:\n\n1. Copy APK to USB drive\n2. Use a file manager app on Android TV\n3. Navigate to APK and install\n\n## API Endpoint Format\n\nYour API should return JSON in this format:\n\n```json\n{\n  \"intro\": {\n    \"start\": 0,\n    \"end\": 90\n  },\n  \"credits\": {\n    \"start\": 2500,\n    \"end\": 2700\n  }\n}\n```\n\n**Important:** All timestamps are in **seconds** (not milliseconds).\n\n## Testing Without a Real API\n\nThe app includes fallback default markers if the API fails:\n- Intro: 0-90 seconds\n- Credits: 2500-2700 seconds\n\nThis allows you to test the skip functionality even without a working API.\n\n## Project Files Overview\n\n```\napp/src/main/\n├── java/com/tvplayer/app/\n│   ├── MainActivity.java      # Main video player activity\n│   ├── ApiService.java        # HTTP client using OkHttp\n│   └── SkipMarkers.java       # Data model for JSON response\n├── res/\n│   ├── layout/\n│   │   └── activity_main.xml  # UI layout with player and buttons\n│   ├── values/\n│   │   ├── styles.xml         # Fullscreen theme\n│   │   └── colors.xml         # Color resources\n│   └── drawable/              # App icons\n└── AndroidManifest.xml        # Permissions and launcher config\n```\n\n## Customization\n\n### Change Button Position\n\nEdit `app/src/main/res/layout/activity_main.xml`:\n- Modify `android:layout_gravity` for positioning\n- Adjust margins and padding\n\n### Modify Auto-Skip Behavior\n\nEdit `MainActivity.java`:\n- `autoSkipIntro()` method: Change auto-skip logic\n- `introAutoSkipped` flag: Control if intro auto-skips only once\n\n### Update Polling Interval\n\nIn `startPositionUpdates()` method, change `500` (ms) to your preferred interval.\n\n## Troubleshooting\n\n**Build fails:**\n- Ensure Java JDK 11+ is installed\n- Verify Android SDK is properly configured\n- Check internet connection for dependency downloads\n\n**API not working:**\n- Check INTERNET permission in AndroidManifest.xml (already included)\n- Verify API URL is accessible from your network\n- Check Logcat logs: `adb logcat | grep TVPlayer`\n\n**Buttons not appearing:**\n- Verify API returns valid JSON\n- Check timestamps are reasonable for your video length\n- Ensure timestamps are in seconds, not milliseconds\n\n## Support for Different Video Formats\n\nExoPlayer supports:\n- HLS (`.m3u8`)\n- DASH (`.mpd`)\n- MP4\n- WebM\n- And many more\n\nJust change the `VIDEO_URL` to your preferred format.\n\n## Questions?\n\nCheck the main `README.md` for detailed documentation and building instructions.\n","size_bytes":4360},"app/src/main/java/com/tvplayer/app/skipdetection/strategies/ManualPreferenceStrategy.java":{"content":"package com.tvplayer.app.skipdetection.strategies;\n\nimport com.tvplayer.app.PreferencesHelper;\nimport com.tvplayer.app.skipdetection.MediaIdentifier;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegment;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegmentType;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.DetectionSource;\nimport com.tvplayer.app.skipdetection.SkipDetectionStrategy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * ManualPreferenceStrategy\n * FUNCTION: This is the fallback strategy. It reads the skip times that the user\n * has manually entered in the app's settings.\n * INTERACTS WITH: PreferencesHelper.java (to read settings).\n * PERSONALIZATION: This strategy is entirely driven by user settings.\n */\npublic class ManualPreferenceStrategy implements SkipDetectionStrategy {\n\n    private final PreferencesHelper prefsHelper;\n\n    public ManualPreferenceStrategy(PreferencesHelper prefsHelper) {\n        this.prefsHelper = prefsHelper;\n    }\n\n    @Override\n    public SkipDetectionResult detect(MediaIdentifier mediaIdentifier) {\n        List<SkipSegment> segments = new ArrayList<>();\n\n        // # Read Intro time from settings\n        int introStart = prefsHelper.getIntroStart();\n        int introEnd = prefsHelper.getIntroEnd();\n        if (introEnd > introStart) {\n            segments.add(new SkipSegment(SkipSegmentType.INTRO, introStart, introEnd));\n        }\n\n        // # Read Recap time from settings\n        int recapStart = prefsHelper.getRecapStart();\n        int recapEnd = prefsHelper.getRecapEnd();\n        if (recapEnd > recapStart) {\n            segments.add(new SkipSegment(SkipSegmentType.RECAP, recapStart, recapEnd));\n        }\n\n        // # Read Credits time from settings\n        // # Note: The 'credits_start' preference is an offset from the end (e.g., 180 seconds)\n        long runtime = mediaIdentifier.getRuntimeSeconds();\n        int creditsOffset = prefsHelper.getCreditsStart();\n        if (creditsOffset > 0 && runtime > 0) {\n            int creditsStart = (int) (runtime - creditsOffset);\n            if (creditsStart > 0) {\n                // # Credits run from the calculated start time to the end of the media\n                segments.add(new SkipSegment(SkipSegmentType.CREDITS, creditsStart, (int) runtime));\n            }\n        }\n\n        // # Read Next Episode marker from settings\n        int nextEpStart = prefsHelper.getNextEpisodeStart();\n        if (nextEpStart > 0 && runtime > 0 && nextEpStart < runtime) {\n             // # This segment is symbolic; its start time is the marker\n            segments.add(new SkipSegment(SkipSegmentType.NEXT_EPISODE, nextEpStart, (int) runtime));\n        }\n\n        if (segments.isEmpty()) {\n            return SkipDetectionResult.failed(DetectionSource.MANUAL_PREFERENCE, \"No manual skip times set.\");\n        }\n\n        // # Manual settings are given a medium-high confidence by default\n        return SkipDetectionResult.success(\n            DetectionSource.MANUAL_PREFERENCE,\n            0.7f,\n            segments.toArray(new SkipSegment[0])\n        );\n    }\n\n    @Override\n    public String getStrategyName() {\n        return \"Manual User Preferences\";\n    }\n\n    @Override\n    public boolean isAvailable() {\n        return true; // # Always available as a fallback\n    }\n\n    @Override\n    public int getPriority() {\n        // # FIX: Set to 100 for P1 Priority (Category 5: Lowest Priority).\n        return 100;\n    }\n}","size_bytes":3552},"info.sh":{"content":"#!/bin/bash\n\nclear\n\ncat << \"EOF\"\n╔═══════════════════════════════════════════════════════════════╗\n║                                                               ║\n║                    TV PLAYER - ANDROID TV APP                 ║\n║                                                               ║\n╚═══════════════════════════════════════════════════════════════╝\n\nThis is an Android TV application built with ExoPlayer.\n\n✅ PROJECT STATUS: Ready to build\n✅ All source files created\n✅ Dependencies configured\n✅ Android TV optimized\n\n📱 FEATURES:\n  • External player support (Stremio, Syncler compatible)\n  • Fullscreen video playback with ExoPlayer\n  • Remote API integration for skip markers  \n  • Auto-skip intro on playback start\n  • Skip Intro button (appears during intro)\n  • Skip Credits button (appears during credits)\n  • D-pad navigation for Firestick/Android TV remotes\n  • LEANBACK launcher configuration\n\n⚠️  IMPORTANT: This is an Android app that runs on Android TV devices,\n   not in the browser. You need to build an APK and install it on\n   your Android TV, Firestick, or Android TV emulator.\n\n📋 NEXT STEPS:\n\n1. Configure your video and API URLs:\n   Edit: app/src/main/java/com/tvplayer/app/MainActivity.java\n   Lines 28-29\n\n2. Build the APK:\n   • Option A: Use Android Studio (recommended)\n   • Option B: Run ./build.sh (requires Android SDK)\n\n3. Install on your Android TV device:\n   adb install app/build/outputs/apk/debug/app-debug.apk\n\n📚 DOCUMENTATION:\n  • README.md           - Complete documentation and build instructions\n  • SETUP.md            - Step-by-step setup guide  \n  • EXTERNAL_PLAYER.md  - How to use with Stremio/Syncler\n  • FEATURES.md         - Complete feature list\n  • replit.md           - Project structure and architecture\n\n🔧 API FORMAT:\nYour API endpoint should return JSON:\n{\n  \"intro\": { \"start\": 0, \"end\": 90 },\n  \"credits\": { \"start\": 2500, \"end\": 2700 }\n}\n(All timestamps in seconds)\n\n📂 PROJECT STRUCTURE:\napp/src/main/\n├── java/com/tvplayer/app/\n│   ├── MainActivity.java    # Main player activity\n│   ├── ApiService.java      # API client\n│   └── SkipMarkers.java     # Data model\n├── res/layout/\n│   └── activity_main.xml    # UI layout\n└── AndroidManifest.xml      # App configuration\n\nFor detailed instructions, see README.md and SETUP.md\n\nPress Ctrl+C to exit this information screen.\nEOF\n\n# Keep the script running\nwhile true; do\n    sleep 60\ndone\n","size_bytes":2781},"app/src/main/java/com/tvplayer/app/skipdetection/strategies/MetadataHeuristicStrategy.java":{"content":"package com.tvplayer.app.skipdetection.strategies;\n\nimport android.util.Log;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonObject;\nimport com.tvplayer.app.PreferencesHelper;\nimport com.tvplayer.app.skipdetection.MediaIdentifier;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegment;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegmentType;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.DetectionSource;\nimport com.tvplayer.app.skipdetection.SkipDetectionStrategy;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\n/**\n * MetadataHeuristicStrategy\n * FUNCTION: Uses existing Trakt/TMDB IDs to fetch metadata (like runtime) \n * and apply simple heuristics (guesses) to find skip points.\n * INTERACTS WITH: PreferencesHelper.java (for API keys), MediaIdentifier.java (for IDs).\n * PERSONALIZATION: The 'applyHeuristics' method contains the hardcoded rules.\n * You can adjust the times (e.g., '0, 90' for intro) to be more or less aggressive.\n */\npublic class MetadataHeuristicStrategy implements SkipDetectionStrategy {\n\n    private static final String TAG = \"MetadataHeuristicStrategy\";\n    private static final int TIMEOUT_SECONDS = 8;\n\n    // # Base URL for Trakt API lookup (used to get runtime for heuristics).\n    private static final String TRAKT_API_URL = \"https://api.trakt.tv\"; \n\n    private final PreferencesHelper prefsHelper;\n    private final OkHttpClient httpClient;\n    private final Gson gson;\n\n    public MetadataHeuristicStrategy(PreferencesHelper prefsHelper) {\n        this.prefsHelper = prefsHelper;\n        // # HTTP client setup with a reasonable timeout for network requests.\n        this.httpClient = new OkHttpClient.Builder()\n            .connectTimeout(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n            .readTimeout(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n            .writeTimeout(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n            .build();\n        this.gson = new Gson();\n    }\n\n    // # Core detection logic: Fetches runtime and applies time-based guesswork.\n    @Override\n    public SkipDetectionResult detect(MediaIdentifier mediaIdentifier) {\n        // # Use runtime from the media identifier first, if available.\n        long runtimeSeconds = mediaIdentifier.getRuntimeSeconds();\n        boolean isTvShow = mediaIdentifier.getSeasonNumber() != null && mediaIdentifier.getEpisodeNumber() != null;\n\n        // # If runtime is not available, try to fetch it from Trakt using an ID.\n        if (runtimeSeconds <= 0 && isAvailable()) {\n            runtimeSeconds = fetchRuntimeFromTrakt(mediaIdentifier, isTvShow);\n        }\n\n        // # If runtime is still not valid, the strategy cannot proceed.\n        if (runtimeSeconds <= 0) {\n            return SkipDetectionResult.failed(DetectionSource.METADATA_HEURISTIC, \"No valid runtime found or fetched.\");\n        }\n\n        List<SkipSegment> segments = new ArrayList<>();\n\n        // # Apply simple rules (heuristics) based on the total length of the content.\n        applyHeuristics(segments, runtimeSeconds, isTvShow);\n\n        if (segments.isEmpty()) {\n            return SkipDetectionResult.failed(DetectionSource.METADATA_HEURISTIC, \"Heuristics did not generate any skip segments.\");\n        }\n\n        // # Returns a result based on calculated guesses. Confidence is moderate.\n        return SkipDetectionResult.success(\n            DetectionSource.METADATA_HEURISTIC,\n            0.40f, \n            segments.toArray(new SkipSegment[0])\n        );\n    }\n\n    // # Helper to fetch media runtime from the Trakt API.\n    private long fetchRuntimeFromTrakt(MediaIdentifier mediaIdentifier, boolean isTvShow) {\n        String traktApiKey = prefsHelper.getTraktApiKey();\n        if (traktApiKey.isEmpty()) {\n            return 0; // # Cannot use Trakt without a key\n        }\n\n        String url;\n        String traktId = mediaIdentifier.getTraktId();\n\n        if (traktId != null && !traktId.isEmpty()) {\n            if (isTvShow) {\n                // # Trakt API endpoint for a specific episode.\n                url = String.format(\"%s/shows/%s/seasons/%d/episodes/%d?extended=full\",\n                    TRAKT_API_URL, traktId, mediaIdentifier.getSeasonNumber(), mediaIdentifier.getEpisodeNumber());\n            } else {\n                // # Trakt API endpoint for a movie.\n                url = String.format(\"%s/movies/%s?extended=full\", TRAKT_API_URL, traktId);\n            }\n        } else {\n            return 0; // # No ID to look up\n        }\n\n        Request request = new Request.Builder()\n            .url(url)\n            .header(\"Content-Type\", \"application/json\")\n            .header(\"trakt-api-version\", \"2\")\n            // # Uses the API key stored in preferences for authentication.\n            .header(\"trakt-api-key\", traktApiKey)\n            .build();\n\n        try (Response response = httpClient.newCall(request).execute()) {\n            if (response.isSuccessful() && response.body() != null) {\n                String json = response.body().string();\n                JsonObject jsonObject = gson.fromJson(json, JsonObject.class);\n\n                // # Trakt runtime is usually returned in minutes, convert to seconds.\n                if (jsonObject.has(\"runtime\")) {\n                    return jsonObject.get(\"runtime\").getAsLong() * 60; \n                }\n            }\n        } catch (Exception e) {\n            Log.e(TAG, \"Error fetching from Trakt\", e);\n        }\n        return 0;\n    }\n\n    // # Simple, hardcoded rules to guess where segments might be based on total runtime.\n    private void applyHeuristics(List<SkipSegment> segments, long runtimeSeconds, boolean isTvShow) {\n        if (!isTvShow) {\n            return; // # Heuristics are generally less reliable for movies\n        }\n\n        if (runtimeSeconds >= 20 * 60) { // # 20+ minute episode\n            // # Assume a 0-90 second intro.\n            segments.add(new SkipSegment(SkipSegmentType.INTRO, 0, 90));\n            // # Assume credits start 180 seconds before the end.\n            int creditsStart = (int) (runtimeSeconds - 180);\n            if (creditsStart > 0) {\n                segments.add(new SkipSegment(SkipSegmentType.CREDITS, creditsStart, (int) runtimeSeconds));\n            }\n        } else if (runtimeSeconds >= 15 * 60) { // # 15-19 minute episode\n            // # Assume a 0-60 second intro.\n            segments.add(new SkipSegment(SkipSegmentType.INTRO, 0, 60));\n            // # Assume credits start 120 seconds before the end.\n            int creditsStart = (int) (runtimeSeconds - 120);\n            if (creditsStart > 0) {\n                segments.add(new SkipSegment(SkipSegmentType.CREDITS, creditsStart, (int) runtimeSeconds));\n            }\n        }\n    }\n\n    @Override\n    public String getStrategyName() {\n        return \"Metadata-Based Heuristics\";\n    }\n\n    @Override\n    public boolean isAvailable() {\n        // # Strategy is available if the user has provided at least one API key.\n        return !prefsHelper.getTmdbApiKey().isEmpty() || \n               !prefsHelper.getTraktApiKey().isEmpty() ||\n               !prefsHelper.getTvdbApiKey().isEmpty();\n    }\n\n    @Override\n    public int getPriority() {\n        // # FIX: Set to 500 for P1 Priority (Category 1: Chapter/Metadata).\n        return 500;\n    }\n}","size_bytes":7449},"app/src/main/java/com/tvplayer/app/skipdetection/strategies/IntroSkipperStrategy.java":{"content":"package com.tvplayer.app.skipdetection.strategies;\n\nimport android.util.Log;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonObject;\nimport com.tvplayer.app.skipdetection.MediaIdentifier;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegment;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegmentType;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.DetectionSource;\nimport com.tvplayer.app.skipdetection.SkipDetectionStrategy;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\n/**\n * IntroSkipperStrategy\n * FUNCTION: Detects skip segments by querying the Intro-Skipper community API (used by Stremio/Jellyfin).\n * INTERACTS WITH: Intro-Skipper public server (requires Internet), MediaIdentifier.java (for Trakt ID).\n * PERSONALIZATION: The STREMIO_API_URL can be changed to a different mirror or custom endpoint.\n */\npublic class IntroSkipperStrategy implements SkipDetectionStrategy {\n\n    private static final String TAG = \"IntroSkipperStrategy\";\n    // # This is a proxy/mirror of the official service.\n    private static final String STREMIO_API_URL = \"https://busy-jacinta-shugi-c2885b2e.koyeb.app\";\n    private static final int TIMEOUT_SECONDS = 8;\n\n    private final OkHttpClient httpClient;\n    private final Gson gson;\n    private final String customEndpoint;\n\n    // # Constructor 1: Uses the default Stremio API URL.\n    public IntroSkipperStrategy() {\n        this(null);\n    }\n\n    // # Constructor 2: Allows a custom endpoint (useful for development or alternate mirrors).\n    public IntroSkipperStrategy(String customEndpoint) {\n        this.httpClient = new OkHttpClient.Builder()\n            .connectTimeout(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n            .readTimeout(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n            .writeTimeout(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n            .build();\n        this.gson = new Gson();\n        this.customEndpoint = customEndpoint;\n    }\n\n    // # Core detection logic: Constructs a URL and fetches skip segments from the API.\n    @Override\n    public SkipDetectionResult detect(MediaIdentifier mediaIdentifier) {\n        String traktId = mediaIdentifier.getTraktId();\n        Integer season = mediaIdentifier.getSeasonNumber();\n        Integer episode = mediaIdentifier.getEpisodeNumber();\n\n        if (traktId == null || traktId.isEmpty() || season == null || episode == null) {\n            return SkipDetectionResult.failed(DetectionSource.INTRO_SKIPPER_API, \"Missing Trakt ID or episode info.\");\n        }\n\n        String baseUrl = customEndpoint != null ? customEndpoint : STREMIO_API_URL;\n        // # Constructs the API URL for a specific episode using the Trakt ID.\n        String url = String.format(\"%s/trakt/%s/%d/%d\", baseUrl, traktId, season, episode);\n\n        Request request = new Request.Builder()\n            .url(url)\n            .build();\n\n        try (Response response = httpClient.newCall(request).execute()) {\n            if (response.isSuccessful() && response.body() != null) {\n                String json = response.body().string();\n                List<SkipSegment> segments = parseResponse(json);\n\n                if (!segments.isEmpty()) {\n                    Log.d(TAG, \"Intro-Skipper detection successful with \" + segments.size() + \" segments\");\n                    // # Returns a high-confidence result\n                    return SkipDetectionResult.success(\n                        DetectionSource.INTRO_SKIPPER_API,\n                        0.75f,\n                        segments.toArray(new SkipSegment[0])\n                    );\n                } else {\n                    return SkipDetectionResult.failed(DetectionSource.INTRO_SKIPPER_API, \"API returned no skip data.\");\n                }\n            } else {\n                return SkipDetectionResult.failed(DetectionSource.INTRO_SKIPPER_API, \n                    \"API call failed: \" + response.code());\n            }\n        } catch (Exception e) {\n            Log.e(TAG, \"Network error during Intro-Skipper lookup\", e);\n            return SkipDetectionResult.failed(DetectionSource.INTRO_SKIPPER_API, \"Network error: \" + e.getMessage());\n        }\n    }\n\n    // # Helper method to parse the JSON response from the API.\n    private List<SkipSegment> parseResponse(String json) {\n        List<SkipSegment> segments = new ArrayList<>();\n        try {\n            JsonObject root = gson.fromJson(json, JsonObject.class);\n            if (root.has(\"skipSegments\") && root.get(\"skipSegments\").isJsonArray()) {\n                JsonArray segmentsArray = root.get(\"skipSegments\").getAsJsonArray();\n                for (int i = 0; i < segmentsArray.size(); i++) {\n                    JsonObject segment = segmentsArray.get(i).getAsJsonObject();\n                    String typeStr = segment.has(\"skipType\") ? segment.get(\"skipType\").getAsString().toLowerCase() : \"\";\n                    double start = segment.has(\"showSkipPromptAt\") ? segment.get(\"showSkipPromptAt\").getAsDouble() : 0;\n                    double end = segment.has(\"hideSkipPromptAt\") ? segment.get(\"hideSkipPromptAt\").getAsDouble() : 0;\n\n                    if (start >= 0 && end > start) {\n                        if (typeStr.contains(\"intro\") || typeStr.contains(\"opening\")) {\n                            segments.add(new SkipSegment(SkipSegmentType.INTRO, (int) start, (int) end));\n                        } else if (typeStr.contains(\"recap\")) {\n                            segments.add(new SkipSegment(SkipSegmentType.RECAP, (int) start, (int) end));\n                        } else if (typeStr.contains(\"credits\") || typeStr.contains(\"outro\")) {\n                            segments.add(new SkipSegment(SkipSegmentType.CREDITS, (int) start, (int) end));\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            Log.e(TAG, \"Error parsing intro-skipper response\", e);\n        }\n        return segments;\n    }\n\n    @Override\n    public String getStrategyName() {\n        return \"Intro-Skipper (Stremio/Jellyfin)\";\n    }\n\n    @Override\n    public boolean isAvailable() {\n        return true; // # The API is generally always available to try.\n    }\n\n    @Override\n    public int getPriority() {\n        // # FIX: Set to 400 for P1 Priority (Category 3: Community Servers).\n        return 400;\n    }\n}","size_bytes":6532},"app/src/main/java/com/tvplayer/app/skipdetection/strategies/AudioFingerprintStrategy.java":{"content":"package com.tvplayer.app.skipdetection.strategies;\n\nimport android.util.Log;\n\nimport com.tvplayer.app.skipdetection.MediaIdentifier;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult;\nimport com.tvplayer.app.skipdetection.SkipDetectionResult.DetectionSource;\nimport com.tvplayer.app.skipdetection.SkipDetectionStrategy;\n\n/**\n * AudioFingerprintStrategy (Placeholder)\n * FUNCTION: This is a placeholder for a future strategy that would scan the audio\n * track to detect intros/recaps (e.g., by detecting silence or repeated theme music).\n * INTERACTS WITH: SmartSkipManager.java (which includes it in the priority list).\n * PERSONALIZATION: This file is non-functional. The 'detect' method returns 'failed'\n * until a real audio analysis library is implemented.\n */\npublic class AudioFingerprintStrategy implements SkipDetectionStrategy {\n\n    private static final String TAG = \"AudioFingerprintStrategy\";\n\n    public AudioFingerprintStrategy() {\n        // # Initialization for audio analysis components would go here.\n    }\n\n    /**\n     * Core detection logic (Placeholder).\n     * This is where audio processing would happen.\n     */\n    @Override\n    public SkipDetectionResult detect(MediaIdentifier mediaIdentifier) {\n\n        Log.d(TAG, \"Audio fingerprint detection is a placeholder and not yet implemented.\");\n\n        // # This strategy will always fail until it is implemented.\n        return SkipDetectionResult.failed(DetectionSource.AUDIO_FINGERPRINT, \"Audio analysis not implemented.\");\n\n        /* // Example of a successful return structure if it were implemented:\n        if (foundIntro) {\n             SkipSegment intro = new SkipSegment(SkipSegmentType.INTRO, 50, 120);\n             return SkipDetectionResult.success(DetectionSource.AUDIO_FINGERPRINT, 0.60f, intro);\n        }\n        */\n    }\n\n    @Override\n    public String getStrategyName() {\n        return \"Audio Fingerprint Scanning\";\n    }\n\n    @Override\n    public boolean isAvailable() {\n        // # Set to true so it appears in the priority list, even though it will fail.\n        // # Set to false to disable it entirely.\n        return true; \n    }\n\n    @Override\n    public int getPriority() {\n        // # FIX: Set to 300 for P1 Priority (Category 4: Audio Scanning).\n        return 300;\n    }\n}","size_bytes":2289},"build.sh":{"content":"#!/bin/bash\n\necho \"======================================\"\necho \"TV Player - Android TV App Build Script\"\necho \"======================================\"\necho \"\"\n\n# Check if Java is installed\nif ! command -v java &> /dev/null; then\n    echo \"ERROR: Java is not installed or not in PATH\"\n    echo \"Please install Java JDK 11 or later\"\n    exit 1\nfi\n\necho \"Java version:\"\njava -version\necho \"\"\n\n# Check if ANDROID_HOME is set\nif [ -z \"$ANDROID_HOME\" ]; then\n    echo \"WARNING: ANDROID_HOME is not set\"\n    echo \"\"\n    echo \"To build Android apps, you need to install Android SDK:\"\n    echo \"\"\n    echo \"1. Download command line tools:\"\n    echo \"   wget https://dl.google.com/android/repository/commandlinetools-linux-9477386_latest.zip\"\n    echo \"\"\n    echo \"2. Setup SDK:\"\n    echo \"   mkdir -p ~/android-sdk/cmdline-tools\"\n    echo \"   unzip commandlinetools-linux-9477386_latest.zip -d ~/android-sdk/cmdline-tools\"\n    echo \"   cd ~/android-sdk/cmdline-tools && mkdir latest\"\n    echo \"   mv bin lib NOTICE.txt source.properties latest/\"\n    echo \"\"\n    echo \"3. Set environment variables:\"\n    echo \"   export ANDROID_HOME=~/android-sdk\"\n    echo \"   export PATH=\\$ANDROID_HOME/cmdline-tools/latest/bin:\\$PATH\"\n    echo \"   export PATH=\\$ANDROID_HOME/platform-tools:\\$PATH\"\n    echo \"\"\n    echo \"4. Install SDK packages:\"\n    echo \"   yes | sdkmanager --licenses\"\n    echo \"   sdkmanager \\\"platform-tools\\\" \\\"platforms;android-34\\\" \\\"build-tools;34.0.0\\\"\"\n    echo \"\"\n    echo \"After setup, run this script again to build the APK.\"\n    exit 1\nfi\n\necho \"ANDROID_HOME: $ANDROID_HOME\"\necho \"\"\n\n# Make gradlew executable\nchmod +x gradlew\n\n# Build the app\necho \"Building debug APK...\"\n./gradlew assembleDebug\n\nif [ $? -eq 0 ]; then\n    echo \"\"\n    echo \"======================================\"\n    echo \"Build successful!\"\n    echo \"======================================\"\n    echo \"\"\n    echo \"APK location: app/build/outputs/apk/debug/app-debug.apk\"\n    echo \"\"\n    echo \"To install on Android TV:\"\n    echo \"  adb connect YOUR_TV_IP:5555\"\n    echo \"  adb install app/build/outputs/apk/debug/app-debug.apk\"\n    echo \"  adb shell am start -n com.tvplayer.app/.MainActivity\"\n    echo \"\"\nelse\n    echo \"\"\n    echo \"Build failed. Check the error messages above.\"\n    exit 1\nfi\n","size_bytes":2271},"app/src/main/java/com/tvplayer/app/SettingsActivity.java":{"content":"package com.tvplayer.app;\n\nimport android.os.Bundle;\nimport androidx.appcompat.app.AppCompatActivity;\nimport androidx.preference.PreferenceFragmentCompat;\n\npublic class SettingsActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_settings);\n\n        if (savedInstanceState == null) {\n            getSupportFragmentManager()\n                    .beginTransaction()\n                    .replace(R.id.settings_container, new SettingsFragment())\n                    .commit();\n        }\n\n        if (getSupportActionBar() != null) {\n            getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n    }\n\n    @Override\n    public boolean onSupportNavigateUp() {\n        finish();\n        return true;\n    }\n\n    public static class SettingsFragment extends PreferenceFragmentCompat {\n        @Override\n        public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {\n            setPreferencesFromResource(R.xml.preferences, rootKey);\n        }\n    }\n}","size_bytes":1121},"FEATURES.md":{"content":"# TV Player Features\n\n## ✅ Implemented Features\n\n### 1. External Player Support\n- **Intent-Filter Configuration**: Responds to ACTION_VIEW intents\n- **Stremio/Syncler Compatible**: Works as external player for streaming apps\n- **URL Validation**: Validates http/https video URLs from external apps\n- **Graceful Error Handling**: Shows error message if invalid URL provided\n- **Dual Launch Modes**: Standalone app or external player\n\n### 2. Fullscreen Video Playback\n- **ExoPlayer Integration**: Industry-standard media player for Android\n- **Fullscreen PlayerView**: Optimized for TV displays\n- **Persistent Screen**: Screen stays on during playback\n- **Lifecycle Management**: Proper pause/resume handling\n\n### 3. Remote API Integration\n- **HTTP Client**: OkHttp for reliable API calls\n- **JSON Parsing**: Gson for deserializing skip markers\n- **Error Handling**: Fallback to default markers if API fails\n- **Async Processing**: Non-blocking API requests with callbacks\n\n### 4. Auto-Skip Intro\n- **Automatic Seeking**: Skips intro on first playback entry\n- **Single Execution**: Protected by `introAutoSkipped` flag\n- **Smart Timing**: Works regardless of when markers load\n- **Fallback Support**: Uses default markers if API unavailable\n\n### 5. Skip Intro Button\n- **Dynamic Visibility**: Appears during intro range\n- **Manual Control**: Users can skip intro if they rewind\n- **D-pad Navigation**: Fully focusable for remote control\n- **Position-Based**: Hides when outside intro range\n\n### 6. Skip Credits Button\n- **Range Detection**: Shows during credits timestamps\n- **Seek to End**: Jumps to video end when clicked\n- **Remote Friendly**: Supports D-pad navigation\n- **Real-time Updates**: Visibility updated every 500ms\n\n### 7. Android TV Optimization\n- **LEANBACK Launcher**: Appears in TV home screen\n- **Banner Icon**: Vector drawable for all resolutions\n- **Touchscreen Optional**: Not required for TV devices\n- **Focus Management**: All buttons support D-pad navigation\n\n### 8. Proper Permissions\n- **INTERNET**: Required for video streaming and API calls\n- **SYSTEM_ALERT_WINDOW**: For overlay capabilities\n- **Leanback Feature**: Marks app as TV-compatible\n\n## Technical Implementation\n\n### Skip Marker Format\n```json\n{\n  \"intro\": {\n    \"start\": 0,\n    \"end\": 90\n  },\n  \"credits\": {\n    \"start\": 2500,\n    \"end\": 2700\n  }\n}\n```\n\nAll timestamps are in **seconds**.\n\n### Auto-Skip Logic\n1. API fetches markers on app start\n2. Periodic check (500ms) monitors playback position\n3. When entering intro range for first time, auto-seeks to end\n4. `introAutoSkipped` flag prevents duplicate seeks\n5. Button remains visible for manual skip if user rewinds\n\n### Button Visibility Logic\n- **Skip Intro**: Visible when `currentPosition >= intro.start AND currentPosition < intro.end`\n- **Skip Credits**: Visible when `currentPosition >= credits.start AND currentPosition < credits.end`\n\n### Resource Management\n- Handler callbacks cleaned up in `onDestroy()`\n- ExoPlayer released properly\n- No memory leaks or resource retention\n\n## Customization Points\n\n### Change Video Source\n```java\n// MainActivity.java line 27\nprivate static final String VIDEO_URL = \"YOUR_VIDEO_URL\";\n```\n\n### Configure API Endpoint\n```java\n// MainActivity.java line 28\nprivate static final String MARKERS_API_URL = \"YOUR_API_URL\";\n```\n\n### Adjust Polling Interval\n```java\n// MainActivity.java line 119\nupdateHandler.postDelayed(this, 500); // Change 500 to desired ms\n```\n\n### Modify Default Markers\n```java\n// MainActivity.java createDefaultMarkers() method\nmarkers.intro.start = 0;\nmarkers.intro.end = 90;\nmarkers.credits.start = 2500;\nmarkers.credits.end = 2700;\n```\n\n## Supported Video Formats\n- HLS (`.m3u8`)\n- DASH (`.mpd`)\n- MP4\n- WebM\n- MKV\n- And more (ExoPlayer supports many codecs)\n\n## Tested Scenarios\n✅ Auto-skip on first playback\n✅ Button visibility during ranges\n✅ Manual skip after auto-skip\n✅ Rewind and re-skip functionality\n✅ API success and error paths\n✅ Proper resource cleanup\n✅ No duplicate seeks\n✅ D-pad navigation\n\n## Next Enhancements (Optional)\n- [ ] User preference to disable auto-skip\n- [ ] Episode queue and auto-play next\n- [ ] Playback controls overlay (play/pause, rewind, forward)\n- [ ] Settings screen for API configuration\n- [ ] Analytics tracking for skip usage\n- [ ] Cache markers locally for offline playback\n- [ ] Support for multiple skip ranges per video\n","size_bytes":4392},"app/src/main/java/com/tvplayer/app/skipdetection/SkipDetectionCallback.java":{"content":"package com.tvplayer.app.skipdetection;\n\npublic interface SkipDetectionCallback {\n\n    void onDetectionComplete(SkipDetectionResult result);\n\n    void onDetectionFailed(String errorMessage);\n}","size_bytes":192}},"version":2}