package com.tvplayer.app;

// Standard Android framework imports
import android.app.AlertDialog;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.view.KeyEvent; 
import android.view.MotionEvent; 
import android.view.View;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.ImageButton;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

// AndroidX/AppCompat (UI and compatibility support)
import androidx.appcompat.app.AppCompatActivity;

// Media3/ExoPlayer imports for video playback
import androidx.media3.common.MediaItem;
import androidx.media3.common.PlaybackException;
import androidx.media3.common.Player;
import androidx.media3.exoplayer.ExoPlayer;
import androidx.media3.ui.PlayerView;

// Java standard utility imports for time/date formatting
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

// Smart Skip Detection imports
import com.tvplayer.app.skipdetection.SmartSkipManager;
import com.tvplayer.app.skipdetection.MediaIdentifier;
import com.tvplayer.app.skipdetection.SkipDetectionCallback;
import com.tvplayer.app.skipdetection.SkipDetectionResult;
import com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegment;
import com.tvplayer.app.skipdetection.SkipDetectionResult.SkipSegmentType;
import com.tvplayer.app.skipdetection.SkipDetectionResult.DetectionSource;

public class MainActivity extends AppCompatActivity implements Player.Listener {

    // --- VIEW DECLARATIONS ---
    // Core video player view from Media3 library
    private PlayerView playerView;
    // Main player instance
    private ExoPlayer player;
    // Skip button UI elements
    private Button btnSkipIntro;
    private Button btnSkipRecap;
    private Button btnSkipCredits;
    private Button btnNextEpisode;
    // NEW: Button to cancel the skip prompt
    private Button btnSkipCancel;
    // UI containers/overlays
    private View customControls;
    private View skipButtonsOverlayContainer;

    // Time/Progress UI elements
    private ProgressBar progressBar;
    private TextView tvCurrentTime;
    private TextView tvTotalTime;
    private TextView tvRemainingTime;
    private TextView tvFinishTime;
    
    // Control buttons (only for Play/Pause in this context)
    private ImageButton btnPlayPause;
    
    // --- UTILITY/LOGIC CLASS DECLARATIONS ---
    private PreferencesHelper prefsHelper;
    private SkipMarkers skipMarkers;
    private SmartSkipManager smartSkipManager;
    private Handler handler;
    
    // --- PLAYBACK/CONTROL STATE VARIABLES ---
    private boolean controlsVisible = false;
    private long controlsTimeoutMs = 5000;
    private static final int SCRUB_INTERVAL_MS = 250; 
    private static final int SCRUB_STEP_MS = 5000;
    private long scrubStartTimestamp = 0;
    private int scrubMultiplier = 0;

    // --- TIMING / FORMATTING UTILITIES ---
    private final SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm", Locale.getDefault());
    private final SimpleDateFormat durationFormat = new SimpleDateFormat("HH:mm:ss", Locale.getDefault());
    
    // Runnable for updating the progress bar and time labels
    private final Runnable progressRunnable = new Runnable() {
        @Override
        public void run() {
            if (player != null && player.isPlaying()) {
                updateProgress();
            }
            // Schedule the next update
            handler.postDelayed(this, 1000);
        }
    };
    
    // Runnable for hiding the controls after a timeout
    private final Runnable hideControlsRunnable = new Runnable() {
        @Override
        public void run() {
            if (controlsVisible) {
                toggleControls();
            }
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // --- 1. INITIALIZE UTILITY CLASSES ---
        prefsHelper = new PreferencesHelper(this);
        skipMarkers = new SkipMarkers();
        handler = new Handler(Looper.getMainLooper());

        // --- 2. FIND VIEWS BY ID ---
        playerView = findViewById(R.id.playerView);
        customControls = findViewById(R.id.customControlsOverlay);
        skipButtonsOverlayContainer = findViewById(R.id.skipButtonsOverlayContainer);

        progressBar = findViewById(R.id.progressBar);
        tvCurrentTime = findViewById(R.id.tvCurrentTime);
        tvTotalTime = findViewById(R.id.tvTotalTime);
        tvRemainingTime = findViewById(R.id.tvRemainingTime);
        tvFinishTime = findViewById(R.id.tvFinishTime);
        btnPlayPause = findViewById(R.id.btnPlayPause);

        // Skip Buttons
        btnSkipIntro = findViewById(R.id.btnSkipIntro);
        btnSkipRecap = findViewById(R.id.btnSkipRecap);
        btnSkipCredits = findViewById(R.id.btnSkipCredits);
        btnNextEpisode = findViewById(R.id.btnNextEpisode);
        // NEW: Initialize the Cancel button
        btnSkipCancel = findViewById(R.id.btnSkipCancel);


        // --- 3. SET UP CONTROL LISTENERS ---
        // Listener to toggle controls when the screen is touched/clicked
        playerView.setOnClickListener(v -> toggleControls());
        // Listener to reset the hide-controls timer on user interaction
        playerView.setOnTouchListener((v, event) -> {
            resetControlsTimeout();
            return false;
        });
        
        // --- 4. SET UP BUTTON LISTENERS ---
        setupControlListeners();
        setupSkipButtonListeners();

        // --- 5. INITIALIZE PLAYER AND LOAD MEDIA ---
        initializePlayer();
        
        // Load initial intent (e.g., from Stremio or a file manager)
        handleIntent(getIntent());
    }
    
    // --- INITIALIZATION HELPERS ---
    
    private void initializePlayer() {
        // Initializes ExoPlayer instance and sets it up with the PlayerView
        player = new ExoPlayer.Builder(this).build();
        playerView.setPlayer(player);
        player.addListener(this);
    }
    
    private void setupControlListeners() {
        // Sets up listeners for the Playback and Settings control buttons
        
        // Play/Pause button logic
        btnPlayPause.setOnClickListener(v -> {
            if (player != null) {
                if (player.isPlaying()) {
                    player.pause();
                } else {
                    player.play();
                }
                updatePlayPauseButton();
                resetControlsTimeout();
            }
        });
        
        // Settings button to open the SettingsActivity
        ImageButton btnSettings = findViewById(R.id.btnSettings);
        btnSettings.setOnClickListener(v -> {
            Intent intent = new Intent(MainActivity.this, SettingsActivity.class);
            startActivity(intent);
            resetControlsTimeout();
        });
        
        // Rewind/Fast-Forward buttons: These buttons are mainly for touch interaction 
        // as D-pad logic is handled in dispatchKeyEvent.
        ImageButton btnRewind = findViewById(R.id.btnRewind);
        btnRewind.setOnClickListener(v -> {
            if (player != null) player.seekTo(player.getCurrentPosition() - 10000);
            resetControlsTimeout();
        });
        
        ImageButton btnFastForward = findViewById(R.id.btnFastForward);
        btnFastForward.setOnClickListener(v -> {
            if (player != null) player.seekTo(player.getCurrentPosition() + 10000);
            resetControlsTimeout();
        });
        
        // Placeholder for other controls (Playback Speed, Subtitles, Delays)
        // For the sake of a clean file, only the implemented listeners are shown.
        // All other buttons, like audio/subtitle delay, can use a generic click listener.
        findViewById(R.id.btnAudioDelay).setOnClickListener(v -> Toast.makeText(this, "Audio Delay Pressed", Toast.LENGTH_SHORT).show());
        findViewById(R.id.btnSubtitleDelay).setOnClickListener(v -> Toast.makeText(this, "Subtitle Delay Pressed", Toast.LENGTH_SHORT).show());
        findViewById(R.id.btnSubtitles).setOnClickListener(v -> Toast.makeText(this, "Subtitles Pressed", Toast.LENGTH_SHORT).show());
        findViewById(R.id.btnPlaybackSpeed).setOnClickListener(v -> Toast.makeText(this, "Playback Speed Pressed", Toast.LENGTH_SHORT).show());
    }
    
    private void setupSkipButtonListeners() {
        // Sets up listeners for all skip buttons, including the new Cancel button.
        
        // Listener for the Intro Skip button
        btnSkipIntro.setOnClickListener(v -> {
            SkipMarkers.TimeRange intro = skipMarkers.getIntro();
            if (intro.isValid()) {
                // Seek to the end of the intro segment (in milliseconds)
                player.seekTo(intro.end * 1000L);
                // Hide the buttons after the skip is performed
                hideSkipButtons();
            }
        });

        // Listener for the Recap Skip button
        btnSkipRecap.setOnClickListener(v -> {
            SkipMarkers.TimeRange recap = skipMarkers.getRecap();
            if (recap.isValid()) {
                player.seekTo(recap.end * 1000L);
                hideSkipButtons();
            }
        });

        // Listener for the Credits Skip button
        btnSkipCredits.setOnClickListener(v -> {
            SkipMarkers.TimeRange credits = skipMarkers.getCredits();
            if (credits.isValid()) {
                player.seekTo(credits.end * 1000L);
                hideSkipButtons();
            }
        });

        // Listener for the Next Episode button
        btnNextEpisode.setOnClickListener(v -> {
            // Placeholder logic: in a real app, this would trigger loading the next episode
            Toast.makeText(this, "Jumping to Next Episode...", Toast.LENGTH_SHORT).show();
            // In a simple app, we can seek to the end of the video or just hide the buttons
            if (player != null) {
                player.seekTo(player.getDuration()); 
            }
            hideSkipButtons();
        });
        
        // NEW: Listener for the Cancel Skip button
        btnSkipCancel.setOnClickListener(v -> {
            // Dismisses the skip prompt when the user explicitly cancels it
            hideSkipButtons();
            resetControlsTimeout(); // Show controls again briefly after dismissing
        });
    }

    private void handleIntent(Intent intent) {
        // Handles incoming intents to play a video URI, typically from another app (e.g., Stremio)
        if (intent != null && Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getData() != null) {
            Uri videoUri = intent.getData();
            MediaItem mediaItem = MediaItem.fromUri(videoUri);
            player.setMediaItem(mediaItem);
            player.prepare();
            player.play();
        } else {
            // Placeholder for local testing: play a dummy file if no intent is passed
            Toast.makeText(this, "No media URI provided. Player is ready.", Toast.LENGTH_LONG).show();
        }
    }

    // --- PLAYER EVENT HANDLING (Player.Listener implementation) ---

    @Override
    public void onIsPlayingChanged(boolean isPlaying) {
        // Updates the play/pause button icon when the playing state changes
        updatePlayPauseButton();
    }

    @Override
    public void onPlaybackStateChanged(int playbackState) {
        // Handles state changes (e.g., ready, ended)
        if (playbackState == Player.STATE_READY) {
            // Once ready, start the progress bar update loop
            handler.post(progressRunnable);
            // Initiate skip detection
            startSkipDetection();
            // Apply delay preferences
            applyAudioSubtitleDelay();

        } else if (playbackState == Player.STATE_ENDED) {
            // Handle video completion
            Toast.makeText(this, "Playback Ended", Toast.LENGTH_SHORT).show();
            // Release player resources
            releasePlayer();
            // Finish the activity
            finish();
        }
    }

    @Override
    public void onPlayerError(PlaybackException error) {
        // Shows an alert dialog on playback error
        new AlertDialog.Builder(this)
                .setTitle("Playback Error")
                .setMessage(error.getMessage())
                .setPositiveButton(android.R.string.ok, null)
                .show();
    }

    // --- UI AND CONTROL LOGIC ---
    
    private void toggleControls() {
        // Toggles the visibility of the custom control overlay
        if (customControls.getVisibility() == View.VISIBLE) {
            customControls.setVisibility(View.GONE);
            controlsVisible = false;
            // Remove any pending hide runnables
            handler.removeCallbacks(hideControlsRunnable);
        } else {
            customControls.setVisibility(View.VISIBLE);
            controlsVisible = true;
            // Request focus on the play/pause button for D-pad control
            btnPlayPause.requestFocus();
            // Start the hide countdown timer
            resetControlsTimeout();
        }
    }

    private void resetControlsTimeout() {
        // Resets the timer to hide the controls
        if (controlsVisible) {
            handler.removeCallbacks(hideControlsRunnable);
            handler.postDelayed(hideControlsRunnable, controlsTimeoutMs);
        }
    }
    
    private void updatePlayPauseButton() {
        // Updates the icon on the Play/Pause button
        if (player != null) {
            if (player.isPlaying()) {
                btnPlayPause.setImageResource(android.R.drawable.ic_media_pause);
            } else {
                btnPlayPause.setImageResource(android.R.drawable.ic_media_play);
            }
        }
    }

    private void updateProgress() {
        // Updates the progress bar and time text views every second
        if (player == null || player.getDuration() <= 0) {
            return;
        }

        long durationMs = player.getDuration();
        long currentPositionMs = player.getCurrentPosition();

        // Update Progress Bar (max is 1000)
        int progress = (int) ((currentPositionMs * 1000) / durationMs);
        progressBar.setProgress(progress);

        // Update time text views
        tvCurrentTime.setText(durationFormat.format(new Date(currentPositionMs)));
        tvTotalTime.setText(durationFormat.format(new Date(durationMs)));

        // Remaining Time
        long remainingMs = durationMs - currentPositionMs;
        tvRemainingTime.setText(durationFormat.format(new Date(remainingMs)));
        
        // Finish Time
        tvFinishTime.setText(timeFormat.format(new Date(System.currentTimeMillis() + remainingMs)));
        
        // Update the skip buttons visibility and focus state
        updateSkipButtonVisibility();
    }
    
    /**
     * Helper function to hide all skip-related buttons and the overlay container.
     * Called when a skip is performed or the 'Cancel Skip' button is pressed.
     * The hide action is graceful and focuses the PlayerView to prevent D-pad
     * input from activating hidden buttons.
     */
    private void hideSkipButtons() {
        // Hides all skip-related buttons and the overlay container
        skipButtonsOverlayContainer.setVisibility(View.GONE);
        btnSkipIntro.setVisibility(View.GONE);
        btnSkipRecap.setVisibility(View.GONE);
        btnSkipCredits.setVisibility(View.GONE);
        btnNextEpisode.setVisibility(View.GONE);
        btnSkipCancel.setVisibility(View.GONE); // NEW: Ensure cancel button is also hidden
        
        // After hiding, it's good practice to clear the focus if a button in the overlay had it
        // and return focus to the main player view.
        playerView.requestFocus();
    }

    /**
     * Manages the visibility and focus of skip/next episode buttons.
     * Implements priority logic to prevent segment overlap display (Intro > Recap > Credits).
     * Also implements the focus fix by requesting focus on the first visible button.
     */
    private void updateSkipButtonVisibility() {
        // This function runs on a 1-second interval via the progressRunnable.

        if (player == null || skipMarkers == null) {
            return;
        }

        long currentPositionSec = player.getCurrentPosition() / 1000;
        Button buttonToFocus = null; // Will hold the highest priority button to pre-highlight

        // Reset visibility for all buttons at the start of the check
        btnSkipIntro.setVisibility(View.GONE);
        btnSkipRecap.setVisibility(View.GONE);
        btnSkipCredits.setVisibility(View.GONE);
        btnSkipCancel.setVisibility(View.GONE);
        
        // The Next Episode button is set to VISIBLE, but its visibility may be overridden below.
        // It's checked here so its state can be used for focusing priority.
        boolean showNextEp = skipMarkers.isAtNextEpisode(currentPositionSec);
        btnNextEpisode.setVisibility(showNextEp ? View.VISIBLE : View.GONE);
        
        // --- PRIORITY SKIP LOGIC (Intro > Recap > Credits) ---
        // If multiple skip segments overlap in time, only the highest priority button is shown
        
        if (skipMarkers.isInIntro(currentPositionSec)) {
            // Priority 1: Intro. Only show Intro.
            btnSkipIntro.setVisibility(View.VISIBLE);
            buttonToFocus = btnSkipIntro;
        } else if (skipMarkers.isInRecap(currentPositionSec)) {
            // Priority 2: Recap. Only show Recap if Intro is not active.
            btnSkipRecap.setVisibility(View.VISIBLE);
            buttonToFocus = btnSkipRecap;
        } else if (skipMarkers.isInCredits(currentPositionSec)) {
            // Priority 3: Credits. Only show Credits if Intro/Recap are not active.
            btnSkipCredits.setVisibility(View.VISIBLE);
            buttonToFocus = btnSkipCredits;
        }

        // --- FOCUS AND CANCEL BUTTON LOGIC ---
        
        // A button is active if either a segment is active OR the Next Episode button is active
        boolean anySkipOrNextButtonVisible = (buttonToFocus != null) || showNextEp;

        if (anySkipOrNextButtonVisible) {
            // Show the overall container and the Cancel button
            skipButtonsOverlayContainer.setVisibility(View.VISIBLE);
            btnSkipCancel.setVisibility(View.VISIBLE);

            // Determine which button to pre-highlight:
            // 1. The highest priority skip segment button (buttonToFocus)
            // 2. The Next Episode button (if it's the only one visible)
            // 3. The Cancel button (as a fallback, to ensure something is always focused)
            
            View focusView = null;
            if (buttonToFocus != null) {
                focusView = buttonToFocus;
            } else if (showNextEp) {
                focusView = btnNextEpisode;
            } else {
                // This case should theoretically not be hit if anySkipOrNextButtonVisible is true
                // but provides a safety net to focus the Cancel button if a segment is active
                // and we decide to always focus Cancel if no segment is active. 
                // Given the logic, it's safest to default to the Cancel button if all else fails.
                focusView = btnSkipCancel;
            }

            // Core Fix: Request focus to make the button 'pre-highlighted' for D-pad control
            if (focusView != null && focusView.getVisibility() == View.VISIBLE) {
                focusView.requestFocus();
            }

        } else {
            // If no skip or next button is active, hide the entire container
            hideSkipButtons();
        }
    }


    // --- SKIP DETECTION LOGIC ---

    private void startSkipDetection() {
        // Initializes and runs the SmartSkipManager to find skip segments
        if (smartSkipManager == null) {
            // Initialize SmartSkipManager only once
            smartSkipManager = new SmartSkipManager(this, prefsHelper, player);
        } else {
            // Rebind player for chapter strategy (if video changes)
            smartSkipManager.rebindPlayer(player);
        }
        
        // Create a basic MediaIdentifier (needs more data for API strategies to work)
        MediaIdentifier mediaIdentifier = new MediaIdentifier.Builder()
            // Placeholder/dummy data, replace with actual media metadata
            .setTitle(player.getMediaMetadata().title != null ? player.getMediaMetadata().title.toString() : "Unknown Title")
            .setRuntimeSeconds(player.getDuration() > 0 ? player.getDuration() / 1000 : 0)
            .build();
            
        // Begin asynchronous detection
        smartSkipManager.detectSkipSegments(mediaIdentifier, new SkipDetectionCallback() {
            @Override
            public void onDetectionComplete(SkipDetectionResult result) {
                // This runs on a background thread, so switch to the Main thread for UI updates
                runOnUiThread(() -> {
                    if (result.isSuccess()) {
                        Toast.makeText(MainActivity.this, "Skip detection success from: " + result.getSource().name(), Toast.LENGTH_SHORT).show();
                        
                        // Map the detected segments to the SkipMarkers class
                        SkipSegment intro = result.getSegmentByType(SkipSegmentType.INTRO);
                        if (intro != null && intro.isValid()) {
                            skipMarkers.setIntro(intro.startSeconds, intro.endSeconds);
                        }
                        
                        SkipSegment recap = result.getSegmentByType(SkipSegmentType.RECAP);
                        if (recap != null && recap.isValid()) {
                            skipMarkers.setRecap(recap.startSeconds, recap.endSeconds);
                        }
                        
                        SkipSegment credits = result.getSegmentByType(SkipSegmentType.CREDITS);
                        if (credits != null && credits.isValid()) {
                            // Note: Credits is handled differently in ManualPreferenceStrategy,
                            // but here we use the exact start/end from the detection result.
                            skipMarkers.setCredits(credits.startSeconds, credits.endSeconds);
                        }
                        
                        // Placeholder for Next Episode marker, can be derived from metadata if available
                        // For now, only the manual preference is used for this marker.
                        skipMarkers.setNextEpisodeStart(prefsHelper.getNextEpisodeStart());
                        
                        // Perform auto-skip if enabled
                        performAutoSkip(result);

                    } else {
                        // On failure, fall back to Manual Preferences
                        Toast.makeText(MainActivity.this, "Skip detection failed: " + result.getErrorMessage(), Toast.LENGTH_LONG).show();
                        // Manual preference is already a fallback in the SmartSkipManager logic,
                        // so we just ensure the markers are loaded.
                        loadManualSkipMarkers();
                    }
                    // Initial update to show buttons if segment is already active
                    updateSkipButtonVisibility();
                });
            }

            @Override
            public void onDetectionFailed(String errorMessage) {
                // Handle critical detection failure
                runOnUiThread(() -> {
                    Toast.makeText(MainActivity.this, "Critical skip detection failure: " + errorMessage, Toast.LENGTH_LONG).show();
                    loadManualSkipMarkers();
                    updateSkipButtonVisibility();
                });
            }
        });
    }

    private void loadManualSkipMarkers() {
        // Loads skip times set manually in the settings (the currently working feature)
        skipMarkers.setIntro(prefsHelper.getIntroStart(), prefsHelper.getIntroEnd());
        skipMarkers.setRecap(prefsHelper.getRecapStart(), prefsHelper.getRecapEnd());
        // For credits, the setting is a countdown from end, so it's loaded as the 'start time'
        skipMarkers.setCreditsFromEnd(prefsHelper.getCreditsStart(), player.getDuration() / 1000);
        skipMarkers.setNextEpisodeStart(prefsHelper.getNextEpisodeStart());
    }
    
    private void performAutoSkip(SkipDetectionResult result) {
        // Checks preferences and automatically seeks if an auto-skip is due
        long currentPositionSec = player.getCurrentPosition() / 1000;
        
        SkipSegment intro = result.getSegmentByType(SkipSegmentType.INTRO);
        if (prefsHelper.isAutoSkipIntro() && intro != null && intro.isValid() && currentPositionSec < intro.endSeconds) {
            player.seekTo(intro.endSeconds * 1000L);
            Toast.makeText(this, "Auto-skipping Intro...", Toast.LENGTH_SHORT).show();
            return;
        }

        SkipSegment recap = result.getSegmentByType(SkipSegmentType.RECAP);
        if (prefsHelper.isAutoSkipRecap() && recap != null && recap.isValid() && currentPositionSec < recap.endSeconds) {
            player.seekTo(recap.endSeconds * 1000L);
            Toast.makeText(this, "Auto-skipping Recap...", Toast.LENGTH_SHORT).show();
            return;
        }
        
        SkipSegment credits = result.getSegmentByType(SkipSegmentType.CREDITS);
        if (prefsHelper.isAutoSkipCredits() && credits != null && credits.isValid() && currentPositionSec < credits.endSeconds) {
            player.seekTo(credits.endSeconds * 1000L);
            Toast.makeText(this, "Auto-skipping Credits...", Toast.LENGTH_SHORT).show();
            return;
        }
    }
    
    private void applyAudioSubtitleDelay() {
        // Applies the audio and subtitle delay settings from preferences
        if (player != null) {
            player.setAudioAttributes(
                player.getAudioAttributes().buildUpon()
                    .setDelay(prefsHelper.getAudioDelayMs())
                    .build()
            );
            player.setSubtitleDelay(prefsHelper.getSubtitleDelayMs());
        }
    }

    // --- ACTIVITY LIFECYCLE MANAGEMENT ---

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        setIntent(intent);
        // Clear old media, then handle the new intent
        releasePlayer();
        initializePlayer();
        handleIntent(intent);
    }

    @Override
    protected void onResume() {
        super.onResume();
        // Re-initialize player if it was released in onStop or if it's null
        if (player == null) {
            initializePlayer();
        }
        // Ensure screen stays on
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
        // Ensure manual markers are loaded after returning from settings
        loadManualSkipMarkers();
        // Resume progress tracking
        handler.post(progressRunnable);
    }

    @Override
    protected void onPause() {
        super.onPause();
        // Remove progress and control-hide callbacks
        handler.removeCallbacks(progressRunnable);
        handler.removeCallbacks(hideControlsRunnable);
        // Allow screen to turn off
        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
        // Pause playback to save battery/state
        if (player != null) {
            player.pause();
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // Clean up resources
        releasePlayer();
        if (smartSkipManager != null) {
            smartSkipManager.shutdown();
        }
    }
    
    private void releasePlayer() {
        // Releases the player instance
        if (player != null) {
            player.removeListener(this);
            player.release();
            player = null;
        }
    }

    // --- D-PAD / KEY EVENT HANDLING ---
    
    private void startScrubbing(int direction) {
        // Starts the fast-scrubbing action on D-pad HOLD
        if (player == null || scrubMultiplier != 0) return;

        scrubMultiplier = direction;
        scrubStartTimestamp = System.currentTimeMillis();
        handler.post(scrubRunnable);
    }

    private void stopScrubbing() {
        // Stops the fast-scrubbing action on D-pad RELEASE
        scrubMultiplier = 0;
        scrubStartTimestamp = 0;
        handler.removeCallbacks(scrubRunnable);
    }
    
    private final Runnable scrubRunnable = new Runnable() {
        @Override
        public void run() {
            // Seeks the player by the determined step in the current direction
            if (player != null && scrubMultiplier != 0) {
                long currentPosition = player.getCurrentPosition();
                long newPosition = currentPosition + (long) scrubMultiplier * SCRUB_STEP_MS;
                player.seekTo(newPosition);
                // Keep the controls visible during scrubbing
                resetControlsTimeout(); 
                // Reschedule for the next seek tick
                handler.postDelayed(this, SCRUB_INTERVAL_MS);
            }
        }
    };


    @Override
    public boolean dispatchKeyEvent(KeyEvent event) {
        // Intercepts key events for custom handling (e.g., D-pad fast-scrub, Play/Pause)

        // --- KEY DOWN ACTION HANDLING ---
        if (event.getAction() == KeyEvent.ACTION_DOWN) {
            
            // Show controls on any key press
            if (customControls.getVisibility() != View.VISIBLE) {
                toggleControls();
            }

            switch (event.getKeyCode()) {
                case KeyEvent.KEYCODE_MEDIA_REWIND:
                case KeyEvent.KEYCODE_DPAD_LEFT:
                    // Start scrubbing left on D-pad Left HOLD
                    startScrubbing(-1);
                    return true;

                case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                    // Start scrubbing right on D-pad Right HOLD
                    startScrubbing(1);
                    return true;
                
                case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
                case KeyEvent.KEYCODE_DPAD_CENTER:
                case KeyEvent.KEYCODE_BUTTON_A:
                    // Catch the first DOWN event to prevent both down/up from firing twice
                    if (event.getRepeatCount() > 0) return true;

                    // Execute action if D-pad Center/Enter is pressed AND controls are hidden
                    if (customControls.getVisibility() != View.VISIBLE && player != null) {
                        // Toggle play/pause only if controls are hidden, otherwise rely on focus logic
                        if (player.isPlaying()) {
                            player.pause();
                        } else {
                            player.play();
                        }
                        updatePlayPauseButton();
                        toggleControls(); // Reshow controls after play/pause
                        return true;
                    } 
                    // If controls ARE visible, let the focus system handle the click on a button
                    break;
                    
                case KeyEvent.KEYCODE_BACK:
                    // Let the system handle the back button, usually calling onBackPressed
                    return super.dispatchKeyEvent(event);
            }

        // --- KEY UP ACTION HANDLING --
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            switch (event.getKeyCode()) {
                case KeyEvent.KEYCODE_MEDIA_REWIND:
                case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
                case KeyEvent.KEYCODE_DPAD_LEFT:
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                    // Stop scrubbing when the D-pad L/R or Media R/FF button is released
                    stopScrubbing();
                    return true;
                
                case KeyEvent.KEYCODE_DPAD_CENTER:
                    // This block consumes the UP event if the controls were hidden, 
                    // preventing accidental button presses after the controls were shown.
                    if (customControls.getVisibility() != View.VISIBLE) {
                        return true; 
                    }
                    break;
            }
        }

        // Fallback: Delegate unhandled keys to PlayerView's internal controller logic 
        // This allows volume, channel up/down, etc., to still function
        if (playerView != null && playerView.dispatchKeyEvent(event)) {
            // Since a PlayerView key event was consumed, the controls should be visible
            customControls.setVisibility(View.VISIBLE);
            resetControlsTimeout();
            return true;
        }

        // Final fallback: pass to the default activity handler
        return super.dispatchKeyEvent(event);
    }
}
